function set_vec_to_above_terrain(vec)
    vec['y'] = g_terrain_pos + g_base_height_inches
    return vec
end

function get_strokes_future_position(base_obj, transform)
    if base_obj == nil then
      return {}
    end
    if str_has_substr(base_obj.getName(), 'Elephant Screen') then
      return {}
    end
    local stroke_points = {}
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['topright']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['topleft']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['botleft']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['botright']))
    table.insert(stroke_points,
        set_vec_to_above_terrain(transform['corners']['topright']))

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_zoc_base(base_obj, transform)
    -- ZOC is 1 basewidth in front.  See Rule 51.2
    local stroke_points = {}
    local p = transform['corners']['topright']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_in_inches,
        y = p['y'],
        z = p['z'] + g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_in_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end
    return stroke_points
end

function get_strokes_zoc_wwg(base_obj, transform)
    -- ZOC is one base width in front.  See Rule 51.2
    local size = get_size(base_obj.getName())
    local color = g_gizmo_zoc_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_zoc_color_player_blue
    end

    local stroke_points = {}
    local tr = { x = size['x'] / 2, y = 0, z = size['z'] / 2 }
    local tl = { x = -size['x'] / 2, y = 0, z = size['z'] / 2 }
    local br = { x = size['x'] / 2, y = 0, z = -size['z'] / 2 }
    local bl = { x = -size['x'] / 2, y = 0, z = -size['z'] / 2 }

    -- TOP

    table.insert(stroke_points, {
        x = tr['x'],
        y = tr['y'],
        z = tr['z']
    })
    table.insert(stroke_points, {
        x = tr['x'],
        y = tr['y'],
        z = tr['z'] + g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = tl['x'],
        y = tl['y'],
        z = tl['z'] + g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = tl['x'],
        y = tl['y'],
        z = tl['z']
    })

    -- SIDE LEFT

    table.insert(stroke_points, {
        x = tl['x'] - g_base_width_in_inches,
        y = tl['y'],
        z = tl['z']
    })
    table.insert(stroke_points, {
        x = bl['x'] - g_base_width_in_inches,
        y = bl['y'],
        z = bl['z']
    })
    table.insert(stroke_points, {
        x = bl['x'],
        y = bl['y'],
        z = bl['z']
    })

    -- BOTTOM

    table.insert(stroke_points, {
        x = bl['x'],
        y = bl['y'],
        z = bl['z'] - g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = br['x'],
        y = br['y'],
        z = br['z'] - g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = br['x'],
        y = br['y'],
        z = br['z']
    })

    -- SIDE RIGHT

    table.insert(stroke_points, {
        x = br['x'] + g_base_width_in_inches,
        y = br['y'],
        z = br['z']
    })
    table.insert(stroke_points, {
        x = tr['x'] + g_base_width_in_inches,
        y = tr['y'],
        z = tr['z']
    })
    table.insert(stroke_points, {
        x = tr['x'],
        y = tr['y'],
        z = tr['z']
    })

    local rotation = transform['rotation']
    local pos = transform['position']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point_relative(paux, pos, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_zoc(base_obj, transform)
    if base_obj == nil then
      return {}
    end
    if str_has_substr(base_obj.getName(), 'Elephant Screen') then
      return {}
    end
    if str_has_substr(base_obj.getName(), 'Camp') then
      -- In Triumph! camps do not have a zoc
      return nil
    end

    if str_has_substr(base_obj.getName(), 'War Wagons') then
        local color = g_gizmo_zoc_color_player_red
        if is_base_blue_player(base_obj) then
            color = g_gizmo_zoc_color_player_blue
        end

        return get_strokes_zoc_wwg(base_obj, transform)
    end

    local stroke_points = {}
    local p = transform['corners']['topright']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_in_inches,
        y = p['y'],
        z = p['z'] + g_base_width_in_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_in_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_zoc_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_zoc_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end


-- See the DBA2 repo for this, is a bit hellish... Combined with way too many
-- FB discussions that these rules are overly complex
function get_strokes_fire_arc(base_obj, transform, shooting_range, max_width)
    local stroke_points = {}
    local p = transform['corners']['topright']

    local max_angle_arc = math.acos(g_base_width_in_inches / shooting_range)
    local side_height = math.sin(max_angle_arc) * shooting_range

    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height
    })
    local radius_right = {
        x = p['x'],
        y = p['y'],
        z = p['z']
    }
    local right_arc = get_coordinates_arc(
        radius_right,
        shooting_range,
        g_precision_circle / 4,
        math.deg(max_angle_arc),
        90)
    array_concat(stroke_points, right_arc)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width,
        y = p['y'],
        z = p['z'] + shooting_range
    })
    local radius_left = {
        x = p['x'] - max_width,
        y = p['y'],
        z = p['z']
    }
    local left_arc = get_coordinates_arc(
        radius_left,
        shooting_range,
        g_precision_circle / 4,
        90,
        90 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, left_arc)
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_fire_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_bow(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_bow_range, g_base_width_in_inches)
end

function get_strokes_art(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_art_range, g_base_width_in_inches)
end

-- WWg fire with like a bow on all edges which is weird as fuck
function get_strokes_fire_around(size, transform, shooting_range, max_width, color)
    local stroke_points = {}
    local tr = { x = size['x'] / 2, y = 0, z = size['z'] / 2 }
    local tl = { x = -size['x'] / 2, y = 0, z = size['z'] / 2 }
    local br = { x = size['x'] / 2, y = 0, z = -size['z'] / 2 }
    local bl = { x = -size['x'] / 2, y = 0, z = -size['z'] / 2 }

    local max_angle_arc = math.acos(g_base_width_in_inches / shooting_range)
    local side_height = math.sin(max_angle_arc) * shooting_range

    -- TOP

    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    local top_right_arc = get_coordinates_arc(
        tr,
        shooting_range,
        g_precision_circle / 4,
        math.deg(max_angle_arc),
        90)
    array_concat(stroke_points, top_right_arc)
    table.insert(stroke_points, {
        x = tr['x'] - size['x'],
        y = tr['y'],
        z = tr['z'] + shooting_range
    })
    local top_left_arc = get_coordinates_arc(
        tl,
        shooting_range,
        g_precision_circle / 4,
        90,
        90 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, top_left_arc)
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + side_height + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + side_height
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - side_height - max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    local middleleft_top_arc = get_coordinates_arc(
        tl,
        shooting_range,
        g_precision_circle / 4,
        180 - (90 - math.deg(max_angle_arc)),
        180)
    array_concat(stroke_points, middleleft_top_arc)
    table.insert(stroke_points, {
        x = tr['x'] - size['x'] - shooting_range,
        y = tr['y'],
        z = tr['z']
    })

    -- Bottom

    table.insert(stroke_points, {
        x = br['x'] - size['x'] - shooting_range,
        y = br['y'],
        z = br['z']
    })
    local middleleft_bot_arc = get_coordinates_arc(
        bl,
        shooting_range,
        g_precision_circle / 4,
        180,
        180 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, middleleft_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - side_height - max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - side_height - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - size['x'] - max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    local left_bot_arc = get_coordinates_arc(
        bl,
        shooting_range,
        g_precision_circle / 4,
        270 - (90 - math.deg(max_angle_arc)),
        270)
    array_concat(stroke_points, left_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] - size['x'],
        y = br['y'],
        z = br['z'] - shooting_range
    })
    table.insert(stroke_points, {
        x = br['x'],
        y = br['y'],
        z = br['z'] - shooting_range
    })
    local right_bot_arc = get_coordinates_arc(
        br,
        shooting_range,
        g_precision_circle / 4,
        270,
        270 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, right_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - side_height - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - side_height
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + side_height + max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + side_height,
        y = br['y'],
        z = br['z'] - max_width
    })
    local middleright_bot_arc = get_coordinates_arc(
        br,
        shooting_range,
        g_precision_circle / 4,
        360 - (90 - math.deg(max_angle_arc)),
        360)
    array_concat(stroke_points, middleright_bot_arc)
    table.insert(stroke_points, {
        x = br['x'] + shooting_range,
        y = br['y'],
        z = br['z']
    })

    -- TOP

    table.insert(stroke_points, {
        x = tr['x'] + shooting_range,
        y = tr['y'],
        z = tr['z']
    })
    local middleright_top_arc = get_coordinates_arc(
        tr,
        shooting_range,
        g_precision_circle / 4,
        0,
        90 - math.deg(max_angle_arc))
    array_concat(stroke_points, middleright_top_arc)
    table.insert(stroke_points, {
        x = tr['x'] + side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + side_height + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + side_height,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })

    local rotation = transform['rotation']
    local pos = transform['position']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point_relative(paux, pos, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_wwg_triumph(base_obj, transform, range)
    local size = get_size(base_obj.getName())
    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_fire_color_player_blue
    end
    return get_strokes_around(size, transform, range, color)
end

function get_strokes_wwg(base_obj, transform)
    local size = get_size(base_obj.getName())
    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_fire_color_player_blue
    end
    return get_strokes_fire_around(size, transform, g_wwg_range, g_base_width_in_inches, color)
end

function get_strokes_around(size, transform, range, color)
    local stroke_points = {}
    local p = transform['corners']['topright']
    local depth = size['z']
    local width = size['x']

    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + range
    })
    table.insert(stroke_points, {
        x = p['x'] - width,
        y = p['y'],
        z = p['z'] + range
    })
    local radius_topleft = {
        x = p['x'] - width,
        y = p['y'],
        z = p['z']
    }
    local topleft_arc = get_coordinates_arc(
        radius_topleft,
        range,
        g_precision_circle / 4,
        90,
        180)
    array_concat(stroke_points, topleft_arc)
    table.insert(stroke_points, {
        x = p['x'] - width - range,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] - width - range,
        y = p['y'],
        z = p['z'] - depth
    })
    local radius_botleft = {
        x = p['x'] - width,
        y = p['y'],
        z = p['z'] - depth
    }
    local botleft_arc = get_coordinates_arc(
        radius_botleft,
        range,
        g_precision_circle / 4,
        180,
        270)
    array_concat(stroke_points, botleft_arc)
    table.insert(stroke_points, {
        x = p['x'] - width,
        y = p['y'],
        z = p['z'] - depth - range
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] - depth - range
    })
    local radius_botright = {
        x = p['x'],
        y = p['y'],
        z = p['z'] - depth
    }
    local botright_arc = get_coordinates_arc(
        radius_botright,
        range,
        g_precision_circle / 4,
        270,
        360)
    array_concat(stroke_points, botright_arc)
    table.insert(stroke_points, {
        x = p['x'] + range,
        y = p['y'],
        z = p['z'] - depth
    })
    table.insert(stroke_points, {
        x = p['x'] + range,
        y = p['y'],
        z = p['z']
    })
    local radius_topright = {
        x = p['x'],
        y = p['y'],
        z = p['z']
    }
    local topright_arc = get_coordinates_arc(
        radius_topright,
        range,
        g_precision_circle / 4,
        0,
        90)
    array_concat(stroke_points, topright_arc)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + range
    })

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_command(base_obj, transform, range)
    local size = get_size(base_obj.getName())
    return get_strokes_around(size, transform, range, g_gizmo_color_command)
end


function has_archer_shooting_arc(base_obj)
  if str_has_substr(base_obj.getName(), 'Archers ')
     or str_has_substr(base_obj.getName(), 'Pavisiers') then
      return true
  end
  local base_def = get_base_definition_from_base_obj(base_obj)
  if base_def == nil then
    return false
  end
  if base_def.shower_shooting then
    return true
  end
  return false
end

function get_strokes_base_pos(obj, transform)
    local strokes = {}

    table.insert(strokes, get_strokes_future_position(obj, transform))

    if has_archer_shooting_arc(obj) then
        table.insert(strokes, get_strokes_bow(obj, transform))
    elseif str_has_substr(obj.getName(), 'Artillery') then
        table.insert(strokes, get_strokes_art(obj, transform))
    elseif str_has_substr(obj.getName(), 'War Wagon') then
        table.insert(strokes, get_strokes_wwg_triumph(obj, transform, g_wwg_range))
    end

    if is_base_army_general(obj) then
        table.insert(strokes, get_strokes_command(obj, transform, g_command_distance_short))
        table.insert(strokes, get_strokes_command(obj, transform, g_command_distance_long))
    end

    if g_zoc_enabled then
        table.insert(strokes, get_strokes_zoc(obj, transform))
    end
    return strokes
end

function get_strokes_pickup(picked_up_object)
    if picked_up_object == nil then
        return {}
    end
    local pos = g_picked_base_initial_transform['position']
    local radius = from_mu_to_in(g_mu_movement)

    local color = g_gizmo_color_player_red
    if is_base_blue_player(picked_up_object) then
        color = g_gizmo_color_player_blue
    end

    local strokes = {}
    table.insert(strokes, get_strokes_arrow_position(picked_up_object, g_picked_base_initial_transform))
    table.insert(strokes, {
        points    = get_coordinates_circle(pos, radius, g_precision_circle),
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    })
    local transform = calculate_transform(picked_up_object)
    local height = g_picked_base_initial_transform['position'].y
    transform['corners']['topright'] = {
        x = transform['corners']['topright'].x, y = height, z = transform['corners']['topright'].z
    }
    transform['corners']['topleft'] = {
        x = transform['corners']['topleft'].x, y = height, z = transform['corners']['topleft'].z
    }
    transform['corners']['botleft'] = {
        x = transform['corners']['botleft'].x, y = height, z = transform['corners']['botleft'].z
    }
    transform['corners']['topright'] = {
        x = transform['corners']['topright'].x, y = height, z = transform['corners']['topright'].z
    }
    transform['corners']['botright'] = {
        x = transform['corners']['botright'].x, y = height, z = transform['corners']['botright'].z
    }
    array_concat(strokes, get_strokes_base_pos(picked_up_object, transform))
    return strokes
end

function get_strokes_future_movements(new_selected_items)
    if new_selected_items == nil or #new_selected_items == 0 then
        return {}
    end

    local strokes = {}
    local magnitude = from_mu_to_in(g_mu_movement)
    for _, obj in ipairs(new_selected_items) do
        if is_base_obj(obj) ~= nil then
            local transform = calculate_future_position(obj, magnitude)

            array_concat(strokes, get_strokes_base_pos(obj, transform))
        end

    end
    return strokes
end

-- This caches the strokes for a given base in certain pos and rotation
-- g_cache_zocs["basename"] =  {
--      "pos" = {x=1,y=1,z=1}
--      "rot" = {x=1,y=1,z=1}
--      "strokes" = {}
--   }
g_cache_zocs = {}

function get_strokes_bases_nothing(bases)
    if bases == nil or #bases == 0 then
        return {}
    end

    local strokes = {}
    for _, obj in ipairs(bases) do
        if g_zoc_enabled then
            local name = obj.getName()
            local pos = obj.getPosition()
            local rot = obj.getRotation()
            if g_cache_zocs[name]
                and g_cache_zocs[name].pos == pos
                and g_cache_zocs[name].rot == rot then

                table.insert(strokes, g_cache_zocs[name].strokes)
            else
                local base_strokes = get_strokes_zoc(obj, calculate_transform(obj))
                table.insert(strokes, base_strokes)
                g_cache_zocs[name] = {}
                g_cache_zocs[name].pos = pos
                g_cache_zocs[name].rot = rot
                g_cache_zocs[name].strokes = base_strokes
            end
        end
    end
    return strokes
end

function get_bases_for_gizmos()
    local all_objs = getAllObjects()
    local bases = get_bases_with_guid(all_objs)

    local picked_base = nil
    if g_picked_base ~= nil then
        local picked_base_obj = g_picked_base.obj
        if bases[picked_base_obj.getGUID()] then
            picked_base = picked_base_obj
            bases[picked_base_obj.getGUID()] = nil
        end
    end

    local bases_selected = {}
    local player_colors = getSeatedPlayers()
    for _, player_color in ipairs(player_colors) do
        local selected_bases_player = Player[player_color].getSelectedObjects()
        if selected_bases_player then
          for _, base in ipairs(selected_bases_player) do
              if bases[base.getGUID()] then
                  table.insert(bases_selected, base)
                  bases[base.getGUID()] = nil
              end
          end
      end
    end

    local other_bases = {}
    for _,base in pairs(bases) do
        table.insert(other_bases, base)
    end

    return bases_selected, picked_base, other_bases
end

function draw_all_gizmos()
    g_draw_all_gizmos = true
end

function draw_all_gizmos_execute()
    local strokes = {}

    if not g_gizmo_drawing_disabled then
      -- This is terrible code!
      local moving_selected_items, pickedup_object, other_bases = get_bases_for_gizmos()

      local t1 = os.clock()
      if pickedup_object then
          array_concat(strokes, get_strokes_pickup(pickedup_object))
      end
      if moving_selected_items and #moving_selected_items > 0 then
          array_concat(strokes, get_strokes_future_movements(moving_selected_items))
      end
      if g_zoc_enabled then
          array_concat(strokes, get_strokes_bases_nothing(other_bases))
      end
    end
    Global.setVectorLines(strokes)
end

function draw_gizmo_wheeling(transforms)
    local strokes = {}
    for obj,transform in pairs(transforms) do
        table.insert(strokes, get_strokes_future_position(obj, transform))
    end
    Global.setVectorLines(strokes)
end

function get_strokes_deployment(pos, color, angle, proportion, width, depth)
    local zpos = 1

    if pos == 'bot' then
        zpos = -1
    end

    local half_width = width / 2
    local half_depth = depth / 2

    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth / 2
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width / 3,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth / 2
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width / 3,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width / 3,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth / 2
    }, center, -angle))

    table.insert(stroke_points, rotate_point_relative({
        x = half_width / 3,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth / 2
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width / 3,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width / 3,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth / 2
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth / 2
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width,
        y = g_table_thickness + g_base_height_inches / 1.5,
        z = zpos * half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_horizontal(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = -half_width,
        y = g_table_thickness + g_base_height_inches / 2,
        z = 0
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width,
        y = g_table_thickness + g_base_height_inches / 2,
        z = 0
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_flank(color, angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = 5 * width / 12,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = 5 * width / 12,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_flank_2(color, angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = - 5 * width / 12,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - 5 * width / 12,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_flank_3(color, angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = 11 * width / 24,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = 11 * width / 24,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_flank_4(color, angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = - 11 * width / 24,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - 11 * width / 24,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = width / 6,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = width / 6,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_2(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = - width / 6,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - width / 6,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_3(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = - width / 3,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - width / 3,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_4(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = width / 3,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = width / 3,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical_5(angle, width, depth)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = width / 2
    local half_depth = depth / 2
    table.insert(stroke_points, rotate_point_relative({
        x = 0,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = 0,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function spawn_text_red(text, pos)
    local params = {
        type = '3DText',
        position = pos,
        rotation = { 90, 0, 0 }
    }
    local obj = spawnObject(params)
    obj.setValue(text)
    obj.TextTool.setFontSize(100)
    obj.setName('Text ' .. text)
    return obj
end

function spawn_text_blue(text, pos)
    local params = {
        type = '3DText',
        position = pos,
        rotation = { 90, 180, 0 }
    }
    local obj = spawnObject(params)
    obj.setValue(text)
    obj.TextTool.setFontSize(100)
    obj.setName('Text ' .. text)
    return obj
end

function spawn_number_red(text, pos)
    local params = {
        type = '3DText',
        position = pos,
        rotation = { 90, 0, 0 }
    }
    local obj = spawnObject(params)
    obj.setValue(text)
    obj.TextTool.setFontSize(150)
    obj.setName('NumberRed ' .. text)
    return obj
end

function spawn_number_blue(text, pos)
    local params = {
        type = '3DText',
        position = pos,
        rotation = { 90, 180, 0 }
    }
    local obj = spawnObject(params)
    obj.setValue(text)
    obj.TextTool.setFontSize(150)
    obj.setName('NumberBlue ' .. text)
    return obj
end

function draw_names_quadrant(size)
    local height_text = g_table_thickness * 2 + g_base_height_tabletop + g_base_height_inches / 1

    spawn_text_red('Left Wing', { -5 * size['x'] / 12, height_text, -size['z'] / 7})

    spawn_text_red('Left Flank', { -3 * size['x'] / 12, height_text, -size['z'] / 7})

    spawn_text_red('Left Center', { -1 * size['x'] / 12, height_text, -size['z'] / 7})

    spawn_text_red('Right Center', { 1 *size['x'] / 12, height_text, -size['z'] / 7})

    spawn_text_red('Right Flank', { 3 * size['x'] / 12, height_text, -size['z'] / 7})

    spawn_text_red('Right Wing', { 5 * size['x'] / 12, height_text, -size['z'] / 7})

    spawn_text_blue('Left Wing', { 5 *size['x'] / 12, height_text, size['z'] / 7})

    spawn_text_blue('Left Flank', { 3 * size['x'] / 12, height_text, size['z'] / 7})

    spawn_text_blue('Left Center', { 1 *size['x'] / 12, height_text, size['z'] / 7})

    spawn_text_blue('Right Center', { -1 * size['x'] / 12, height_text, size['z'] / 7})

    spawn_text_blue('Right Flank', { -3 * size['x'] / 12, height_text, size['z'] / 7})

    spawn_text_blue('Right Wing', { -5 * size['x'] / 12, height_text, size['z'] / 7})
end


function draw_deployment_lines()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable == nil then
        print_error('There is no current table, stored GUID is: ' .. g_current_table)
        return
    end

    local size = gametable.getBoundsNormalized()['size']
    local scale = gametable.getScale()
    local proportion = scale['x']
    local angle = normalize_angle(math.rad(gametable.getRotation()['y']))
    local w = size['x']  / scale['x']
    local h = size['z'] / scale['z']

    local strokes = {}
    table.insert(strokes, get_strokes_quadrant_vertical_2(angle, w, h))
    table.insert(strokes, get_strokes_quadrant_vertical_2(angle, w, h))
    table.insert(strokes, get_strokes_quadrant_vertical(angle, w, h))
    table.insert(strokes, get_strokes_quadrant_horizontal(angle, w, h))
    table.insert(strokes,
        get_strokes_deployment('top',
            g_gizmo_color_player_blue, angle, proportion, w, h))
    table.insert(strokes,
        get_strokes_deployment('bot',
            g_gizmo_color_player_red, angle, proportion, w, h))
    if g_game_settings['is_grand_triumph'] then
        table.insert(strokes, get_strokes_quadrant_vertical_3(angle, w, h))
        table.insert(strokes, get_strokes_quadrant_vertical_4(angle, w, h))
        table.insert(strokes, get_strokes_quadrant_vertical_5(angle, w, h))
        table.insert(strokes, get_strokes_quadrant_vertical_flank_3(g_gizmo_fire_color_player_blue, angle, w, h))
        table.insert(strokes, get_strokes_quadrant_vertical_flank_4(g_gizmo_fire_color_player_blue, angle, w, h))
        draw_names_quadrant(size)
    else
        table.insert(strokes, get_strokes_quadrant_vertical_flank(g_gizmo_fire_color_player_blue, angle, w, h))
        table.insert(strokes, get_strokes_quadrant_vertical_flank_2(g_gizmo_fire_color_player_blue, angle, w, h))
    end

    gametable.setVectorLines(strokes)
end

function remove_deployment_lines()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable ~= nil then
        gametable.setVectorLines({})
    end
    local all_objs = getAllObjects()
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'Text ') then
            -- This executes on next frame
            obj.destroy()
        end
    end
end


function update_deployment_lines()
  if g_game_settings['show_deployment_lines']['wizard'] or g_game_settings['show_deployment_lines']['red'] or  g_game_settings['show_deployment_lines']['blue'] then
    draw_deployment_lines()
  else
    remove_deployment_lines()
  end
end

function get_strokes_arrow_position(base_obj, transform)
    local stroke_points = {}
    local p = transform['position']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })
    table.insert(stroke_points, {
        x = p['x'] - 1,
        y = p['y'],
        z = p['z'] + 1.5
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })
    table.insert(stroke_points, {
        x = p['x'] + 1,
        y = p['y'],
        z = p['z'] + 1.5
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end


function show_gizmo_bua_afterdetach()
    local gametable = getObjectFromGUID(g_current_table)
    local all_objs = getAllObjects()
    local terrains = {}
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'terrain') then
            table.insert(terrains, obj)
        end
    end

    local max_distance_from_table_sq = (g_width_table_in/2)^2 + (g_depth_table_in / 2)^2
    local pos_table = gametable.getPosition()

    local table_height = gametable.getPosition()['y']
    local height_strokes = table_height + g_table_thickness / 2 + g_base_height_inches / 2

    local strokes = {}
    for _,terrain in ipairs(terrains) do
        local terrain_pos = terrain.getPosition()
        local distance = distance_points_flat_sq(pos_table, terrain_pos)
        if distance <= max_distance_from_table_sq
            and pos_table['y'] < terrain_pos['y'] then

            if str_starts_with(terrain.getName(), 'terrain BUA') then

                print_debug('There\'s a BUA at position ' .. vec_to_str(terrain_pos))

                terrain_pos['y'] = height_strokes

                local angle = normalize_angle(math.rad(terrain.getRotation()['y']))
                local scale = terrain.getScale()
                local size = terrain.getBoundsNormalized()['size']
                size = vec_mul_vec(size, scale)
                local corners = compute_corners_coords(size, angle, terrain_pos)
                local transform = get_transform(terrain_pos, corners, angle)

                -- Zone of control is 1 BW, or 2 MU.  See Rule 51.2
                local strokes_zoc = get_strokes_around(size, transform, g_base_width_in_inches, g_gizmo_color_command)
                local strokes_bw = get_strokes_around(size, transform, g_bow_range, g_gizmo_color_command)
                local strokes_art = get_strokes_around(size, transform, g_art_range,  g_gizmo_color_command)

                table.insert(strokes, strokes_zoc)
                table.insert(strokes, strokes_bw)
                table.insert(strokes, strokes_art)
            end
            gametable.addAttachment(terrain)
            print_debug('Reattaching ' .. terrain.getName())
        end
    end
    print_debug('Recalculation for fire gizmos BUAs done')
    Global.setVectorLines(strokes)
end

function show_gizmo_bua()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable == nil then
        print_error('There is no current table, stored GUID is: ' .. g_current_table)
        return
    end

    print_info('Showing BUA fire until deselection. All terrain will be reattached.')
    gametable.removeAttachments()
    Wait.frames(show_gizmo_bua_afterdetach, 1)
end


function make_stroke(stroke_points, stroke_color)
  return
  {
      points    = stroke_points,
      color     = stroke_color,
      thickness = g_line_thickness,
      rotation  = {0,0,0}
  }
end


-- Get the strokes that will be used to show the extended edges of
-- a base.  Used to see if a base is vulnerable to a rear or Flank
-- attack.
function get_strokes_edges(base_obj)
    if base_obj == nil then
        return {}
    end

    local stroke_color
    if is_base_blue_player(base_obj) then
      stroke_color = g_gizmo_color_player_blue
    else
      stroke_color = g_gizmo_color_player_red
    end

    local size = get_size(base_obj.getName())

    local top_bottom_size = shallow_copy(size)
    top_bottom_size.x = 17
    top_bottom_size.z = top_bottom_size.z - g_line_thickness / 2

    local left_right_size = shallow_copy(size)
    left_right_size.x = left_right_size.x - g_line_thickness / 2
    left_right_size.z = 17

   local top_bottom_transform = calculate_transform(base_obj, top_bottom_size)
   local left_right_transform = calculate_transform(base_obj, left_right_size)

    local bottom_stroke_points = {
        set_vec_to_above_terrain(top_bottom_transform['corners']['botright']),
        set_vec_to_above_terrain(top_bottom_transform['corners']['botleft'])
    }
    local bottom_stroke = make_stroke(bottom_stroke_points, stroke_color)

    local left_stroke_points = {
        set_vec_to_above_terrain(left_right_transform['corners']['topleft']),
        set_vec_to_above_terrain(left_right_transform['corners']['botleft'])
    }
    local left_stroke = make_stroke(left_stroke_points, stroke_color)

    local right_stroke_points = {
        set_vec_to_above_terrain(left_right_transform['corners']['topright']),
        set_vec_to_above_terrain(left_right_transform['corners']['botright'])
    }
    local right_stroke = make_stroke(right_stroke_points, stroke_color)

    local strokes = {
      bottom_stroke, left_stroke, right_stroke
    }

    return strokes
end

-- Get the strokes that will show where the bases edges are.
-- infinite lines along a bases edges.
--
-- base_obj: base whose edges are to be revealed
function show_edges(base_obj)
  local strokes =get_strokes_edges(base_obj)
  Global.setVectorLines(strokes)
end
