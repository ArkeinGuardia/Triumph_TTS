
function get_strokes_future_position(base_obj, transform)
    local stroke_points = {}
    table.insert(stroke_points, transform['corners']['topright'])
    table.insert(stroke_points, transform['corners']['topleft'])
    table.insert(stroke_points, transform['corners']['botleft'])
    table.insert(stroke_points, transform['corners']['botright'])
    table.insert(stroke_points, transform['corners']['topright'])

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_zoc(base_obj, transform)
    local stroke_points = {}
    local p = transform['corners']['topright']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        -- We can ignore the y because we assume XZ plane
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_zoc_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_zoc_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end


-- Fire arcs on all but WWG is a range X from the corners
function get_strokes_fire_arc(base_obj, transform, shooting_range, max_width)
    local stroke_points = {}
    local p = transform['corners']['topright']

    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width - g_base_width_inches,
        y = p['y'],
        z = p['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width - g_base_width_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        -- We can ignore the y because we assume XZ plane
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_fire_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_bow(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_bow_range, g_base_width_inches)
end

function get_strokes_art(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_art_range, g_base_width_inches)
end

-- WWg fire with like a bow on all edges which is weird as fuck
function get_strokes_fire_around(base_obj, transform, shooting_range, max_width)
    local stroke_points = {}
    local size = get_size(base_obj.getName())
    local tr = { x = size['x'] / 2, y = 0, z = size['z'] / 2 }
    local br = { x = size['x'] / 2, y = 0, z = -size['z'] / 2 }

    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = tr['x'] - max_width - g_base_width_inches,
        y = tr['y'],
        z = tr['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = tr['x'] - max_width - g_base_width_inches,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] - shooting_range - g_base_width_inches,
        y = tr['y'],
        z = tr['z'] + max_width
    })

    table.insert(stroke_points, {
        x = br['x'] - shooting_range - g_base_width_inches,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - max_width - g_base_width_inches,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] - max_width - g_base_width_inches,
        y = br['y'],
        z = br['z'] - shooting_range
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - shooting_range
    })
    table.insert(stroke_points, {
        x = br['x'] + max_width,
        y = br['y'],
        z = br['z'] - max_width
    })
    table.insert(stroke_points, {
        x = br['x'] + shooting_range,
        y = br['y'],
        z = br['z'] - max_width
    })

    table.insert(stroke_points, {
        x = tr['x'] + shooting_range,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + max_width
    })
    table.insert(stroke_points, {
        x = tr['x'] + max_width,
        y = tr['y'],
        z = tr['z'] + shooting_range
    })

    local rotation = transform['rotation']
    local pos = transform['position']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point_relative(paux, pos, rotation)
        paux['x'] = paux_rotated['x']
        paux['y'] = pos['y']
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_fire_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_wwg(base_obj, transform)
    return get_strokes_fire_around(base_obj, transform, g_wwg_range, g_base_width_inches)
end

function get_strokes_around(base_obj, transform, range, color)
    local stroke_points = {}
    local p = transform['corners']['topright']
    local depth = get_size(base_obj.getName())['z']

    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + range
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] + range
    })
    local radius_topleft = {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z']
    }
    local topleft_arc = get_coordinates_arc(
        radius_topleft,
        range,
        g_precision_circle / 4,
        90,
        180)
    array_concat(stroke_points, topleft_arc)
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches - range,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches - range,
        y = p['y'],
        z = p['z'] - depth
    })
    local radius_botleft = {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] - depth
    }
    local botleft_arc = get_coordinates_arc(
        radius_botleft,
        range,
        g_precision_circle / 4,
        180,
        270)
    array_concat(stroke_points, botleft_arc)
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] - depth - range
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] - depth - range
    })
    local radius_botright = {
        x = p['x'],
        y = p['y'],
        z = p['z'] - depth
    }
    local botright_arc = get_coordinates_arc(
        radius_botright,
        range,
        g_precision_circle / 4,
        270,
        360)
    array_concat(stroke_points, botright_arc)
    table.insert(stroke_points, {
        x = p['x'] + range,
        y = p['y'],
        z = p['z'] - depth
    })
    table.insert(stroke_points, {
        x = p['x'] + range,
        y = p['y'],
        z = p['z']
    })
    local radius_topright = {
        x = p['x'],
        y = p['y'],
        z = p['z']
    }
    local topright_arc = get_coordinates_arc(
        radius_topright,
        range,
        g_precision_circle / 4,
        0,
        90)
    array_concat(stroke_points, topright_arc)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + range
    })

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        -- We can ignore the y because we assume XZ plane
        paux['z'] = paux_rotated['z']
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_command(base_obj, transform, range)
    return get_strokes_around(base_obj, transform, range, g_gizmo_color_command)
end

function draw_gizmo_future_movements(new_selected_items)
    if #new_selected_items == 0 then
        Global.setVectorLines({})
        return
    end

    local strokes = {}
    local magnitude = from_bw_to_in(g_bw_movement)
    for _, obj in ipairs(new_selected_items) do
        if g_bases[obj.getName()] ~= nil then
            local transform = calculate_future_position(obj, magnitude)

            table.insert(strokes, get_strokes_future_position(obj, transform))

            if str_has_substr(obj.getName(), 'Bw')
               or str_has_substr(obj.getName(), 'Cb')
               or str_has_substr(obj.getName(), 'Lb') then
                table.insert(strokes, get_strokes_bow(obj, transform))
            elseif str_has_substr(obj.getName(), 'Art') then
                table.insert(strokes, get_strokes_art(obj, transform))
            elseif str_has_substr(obj.getName(), 'WWg') then
                table.insert(strokes, get_strokes_wwg(obj, transform))
            end

            if str_has_substr(obj.getName(), 'Gen') then
                table.insert(strokes, get_strokes_command(obj, transform, g_command_distance_short))
                table.insert(strokes, get_strokes_command(obj, transform, g_command_distance_long))
            end

            if g_zoc_enabled then
                table.insert(strokes, get_strokes_zoc(obj, transform))
            end
        end

    end
    Global.setVectorLines(strokes)
end

function draw_gizmo_wheeling(transforms)
    local strokes = {}
    for obj,transform in pairs(transforms) do
        table.insert(strokes, get_strokes_future_position(obj, transform))
    end
    Global.setVectorLines(strokes)
end

function get_strokes_deployment(pos, color, angle, proportion)
    local zpos = 1

    if pos == 'bot' then
        zpos = -1
    end

    local half_width = g_width_table_in / 2
    local half_depth = g_depth_table_in / 2

    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = - half_width + from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))

    table.insert(stroke_points, rotate_point_relative({
        x = half_width -from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(4) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * from_bw_to_in(3) / proportion
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width - from_bw_to_in(2) / proportion,
        y = g_table_thickness + g_base_height_inches / 2,
        z = zpos * half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_horizontal(angle)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = g_width_table_in / 2
    local half_depth = g_depth_table_in / 2
    table.insert(stroke_points, rotate_point_relative({
        x = -half_width,
        y = g_table_thickness + g_base_height_inches / 2,
        z = 0
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = half_width,
        y = g_table_thickness + g_base_height_inches / 2,
        z = 0
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_quadrant_vertical(angle)
    local stroke_points = {}
    local center = { x=0, y=0, z=0 }
    local half_width = g_width_table_in / 2
    local half_depth = g_depth_table_in / 2
    table.insert(stroke_points, rotate_point_relative({
        x = 0,
        y = g_table_thickness + g_base_height_inches / 2,
        z = half_depth
    }, center, -angle))
    table.insert(stroke_points, rotate_point_relative({
        x = 0,
        y = g_table_thickness + g_base_height_inches / 2,
        z = -half_depth
    }, center, -angle))

    return {
        points    = stroke_points,
        color     = g_gizmo_color_command,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function spawn_text(text, pos)
    local params = {
        type = '3DText',
        position = pos,
        rotation = { 90, 0, 0 }
    }
    local obj = spawnObject(params)
    obj.setValue(text)
    obj.TextTool.setFontSize(180)

    return obj
end

g_current_numbers = {}
function draw_numbers_quadrant(size)
    local height_text = g_table_thickness * 2 + g_base_height_tabletop + g_base_height_inches / 2


    table.insert(g_current_numbers,
        spawn_text('1', { -size['x'] / 4, height_text, -size['z'] / 4}))

    table.insert(g_current_numbers,
            spawn_text('2', { -size['x'] / 4, height_text, size['z'] / 4}))

    table.insert(g_current_numbers,
        spawn_text('3', { size['x'] / 4, height_text, size['z'] / 4}))

    table.insert(g_current_numbers, 
        spawn_text('4', { size['x'] / 4, height_text, -size['z'] / 4}))
end

function draw_deployment_lines()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable == nil then
        print_error('There is no current table, stored GUID is: ' .. g_current_table)
        return
    end

    local size = gametable.getBoundsNormalized()['size']
    local proportion = size['x'] / g_width_table_in
    local angle = normalize_angle(math.rad(gametable.getRotation()['y']))

    local strokes = {}
    table.insert(strokes,
        get_strokes_deployment('top', g_gizmo_color_player_blue, angle, proportion))
    table.insert(strokes,
        get_strokes_deployment('bot', g_gizmo_color_player_red, angle, proportion))
    table.insert(strokes, get_strokes_quadrant_vertical(angle))
    table.insert(strokes, get_strokes_quadrant_horizontal(angle))

    gametable.setVectorLines(strokes)
    draw_numbers_quadrant(size)
end

function remove_deployment_lines()
    local gametable = getObjectFromGUID(g_current_table)
    if gametable ~= nil then
        gametable.setVectorLines({})
    end
    for _, obj in ipairs(g_current_numbers) do
        obj.destroy()
    end
    g_current_numbers = {}
end

function get_strokes_arrow_position(base_obj, transform)
    local stroke_points = {}
    local p = transform['position']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })
    table.insert(stroke_points, {
        x = p['x'] - 1,
        y = p['y'],
        z = p['z'] + 1.5
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })
    table.insert(stroke_points, {
        x = p['x'] + 1,
        y = p['y'],
        z = p['z'] + 1.5
    })
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + 2
    })

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        -- We can ignore the y because we assume XZ plane
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function draw_pickup_strokes(picked_up_object)
    local pos = g_picked_base_initial_transform['position']
    local radius = from_bw_to_in(g_bw_movement)

    local color = g_gizmo_color_player_red
    if is_base_blue_player(picked_up_object.getName()) then
        color = g_gizmo_color_player_blue
    end

    local strokes = {}
    table.insert(strokes, get_strokes_arrow_position(picked_up_object, g_picked_base_initial_transform))
    table.insert(strokes, {
        points    = get_coordinates_circle(pos, radius, g_precision_circle),
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    })
    Global.setVectorLines(strokes)
end

function draw_transforms()

end
