-- Create the event containing the location of all bases.
function create_history_event_snapshot()
    local result = {type="snapshot", bases={}}
    for _,base in pairs(get_all_bases()) do
        local guid = base.getGUID()
        local pos = base.getPosition()
        local rot = base.getRotation()
        result.bases[guid] =  {
          position={x=pos.x, y=pos.y, z=pos.z},
          rotation={x=rot.x, y=rot.y, z=rot.z}
        }
    end

    result.apply = function()
      apply_snapshot(result)
    end

    result.id =  g_history_stack:size() + 1

    return result
end

-- Are the bases in two snapshots the same?
-- lhs_base: snapshot for a base
-- rhs_base: snapshot for a base
function is_snapshot_base_same(lhs_base, rhs_base)
  print("comparing base ", guid)
  if lhs_base == nil and rhs_base == nil then
    print("true both are nli")
    return true
  end
  if lhs_base == nil or rhs_base == nil then
    print("false one nli")
    return false
  end
  local lhs_pos = lhs_base.position
  local rhs_pos = rhs_base.position
  if lhs_pos.x ~= rhs_pos.x then
    return false
  end
  if lhs_pos.y ~= rhs_pos.y then
    return false
  end
  if lhs_pos.z ~= rhs_pos.z then
    return false
  end
  local lhs_rot = lhs_base.rotation
  local rhs_rot = rhs_base.rotation
  if lhs_rot.x ~= rhs_rot.x then
    return false
  end
  if lhs_rot.y ~= rhs_rot.y then
    return false
  end
  if lhs_rot.z ~= rhs_rot.z then
    return false
  end
  print("same")
  return true
end



-- Restore the bases according to the snapshot
function apply_snapshot(snapshot)
  for guid,base_state in pairs(snapshot.bases) do
    local base = getObjectFromGUID(guid)
    if base == nil then
      print_error("Object no longer exists, was it deleted: " .. tostring(guid))
    else
      base.setPosition(base_state.position)
      base.setRotation(base_state.rotation)
    end
  end
end


function find_previous_base_location(snapshot, guid)
  if snapshot.bases[guid] ~= nil then
    return snapshot.bases[guid]
  end
  if snapshot.previous_snapshot == nil then
    return nil
  end
  return find_previous_base_location(snapshot.previous_snapshot, guid)
end

-- Remove bases in snapshot that have the same values in previous.
function compress_snapshot(snapshot, previous)
  if previous == nil then
    return
  end
  for guid,base in pairs(snapshot.bases) do
    local previous_base = find_previous_base_location(previous, guid)
    if is_snapshot_base_same(base, previous_base) then
      snapshot.bases[guid] = nil
    end
  end
end  

function do_record_snapshot()
  local snapshot = create_history_event_snapshot()
  local previous = g_history_stack:top()
  if previous == nil or previous.type ~= "snapshot" then
    snapshot.previous_snapshot = nil
  else
    snapshot.previous_snapshot = previous
  end
  compress_snapshot(snapshot, snapshot.previous_snapshot)
  if is_table_empty(snapshot.bases) then
    return
  end
  g_history_stack:push(snapshot)
end


-- When all the bases have stopped moving record a snapshot.
function record_snapshot_at_rest()
  while not are_all_bases_are_at_rest() do
     coroutine.yield(0)
  end
  do_record_snapshot()
  return 1
end

-- Places an event for the current location of all bases on the
-- history stack
function history_record_snapshot()
  startLuaCoroutine(self, 'record_snapshot_at_rest')
end
