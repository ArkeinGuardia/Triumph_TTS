-- Are two bases facing a a direction that allows for the snapping rule to take place?
-- stable_rotation_degrees: facing of the base not being moved in dregrees
-- moving_rotation_degrees: facing of the moving base in degrees
function are_facings_degrees_close_enough_to_snap(stable_rotation_degrees, moving_rotation_degrees)
  local angle_diff_degrees = stable_rotation_degrees - moving_rotation_degrees
  angle_diff_degrees = normalize_degrees(angle_diff_degrees)
  while angle_diff_degrees > 90 do
    angle_diff_degrees = angle_diff_degrees - 90
  end
  -- angle is now between 0 and 90
  angle_diff_degrees = angle_diff_degrees - 45
  -- angle is now between -45 and 45
  angle_diff_degrees = math.abs(angle_diff_degrees)
  -- angle is now beteeen 0 and 45.

  local delta = 45 - angle_diff_degrees
  if delta >= g_max_angle_snap_degrees then
      return false
  end
  return true
end

function is_facing_close_enough_for_snapping(stable_base_cached, moving_base_cached)
  local stable_rotation_degrees = stable_base_cached.getRotation()['y']
  local moving_rotation_degrees = moving_base_cached.getRotation()['y']
  return are_facings_degrees_close_enough_to_snap(stable_rotation_degrees, moving_rotation_degrees )
end


-- Are two bases close enough to snap?
-- moving_base: Base being moved, instance of base_cache
-- resting_base: Base that will be snapped against, instance of base_cache
-- distance_sq: Square of the distance that the moving_base will have
-- to be moved to snap.
-- return true if the bases are close enough to snap, false if the
-- distance is too large
function is_bases_close_enough_to_snap(moving_base, resting_base, distance_sq)
  -- small distances are always snapped
  if distance_sq <  g_max_corner_distance_snap then
    return true
  end

  -- large distances are never snapped
  if distance_sq >= g_max_corner_distance_snap_intersect_sq then
    return false
  end

  if not moving_base.intersectsWith(resting_base) then
    return false
  end

  -- since the bases are on top of each other which is not legal in
  -- DBA use a larger threshold to determine if we can snap.
  if distance_sq < g_max_corner_distance_snap_intersect_sq then
    return true
  end

  return false
end


-- is the moved base close enough to be snapped to another base?
-- obj base being moved, instance of base_cache
-- base Other base to compare against, instance of base_cache
function is_snapable(obj, base)
  -- Check if the two bases are pretty close
  local pos = obj.getPosition()
  local pos_base = base.getPosition()
  local distance = distance_points_flat_sq(pos, pos_base)

  -- no snap if the distance is too small
  if distance < 0.0001 then
    return false
  end

  local max_distance
  if obj['is_large_base'] and base['is_large_base'] then
    max_distance = g_max_distance_alignment * 16
  elseif obj['is_large_base'] or base['is_large_base'] then
    max_distance = g_max_distance_alignment * 4
  else
    max_distance = g_max_distance_alignment
  end

  if not (distance < max_distance) then 
    return false
  end

  return is_facing_close_enough_for_snapping(obj, base)
end