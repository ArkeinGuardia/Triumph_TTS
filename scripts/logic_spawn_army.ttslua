

require("Triumph_TTS/assets/assets")
require("Triumph_TTS/scripts/static_maps")
require("Triumph_TTS/scripts/data/data_models")
require("Triumph_TTS/scripts/data/data_settings")
require("Triumph_TTS/scripts/logic_decorations")
require("Triumph_TTS/scripts/utilities_lua")
require("Triumph_TTS/scripts/logic_base_obj")


g_base_index = 1
g_bases = {}



-- If the base is dismountable add a menu item to dismount
-- the base
function add_dismount_context_menu_base(base_obj, is_red_player, command_color)
  local definition = get_base_definition_from_base_obj(base_obj)
  if nil == definition then
    return
  end
  local dismount_as = definition['dismount_as']
  if nil == dismount_as then
    return
  end
  local dismounted_definition = get_base_definition(dismount_as)
  if nil == dismounted_definition then
    return
  end

  local decorations = g_decorations[base_obj.getGUID()]
  if nil == decorations then
    return
  end

  base_obj.addContextMenuItem('Dismount', function()
    local old_name = base_obj.getName()
    local pos = base_obj.getPosition()
    local rotation = base_obj.getRotation()
    local y_rotation = rotation.y
    local old_depth = get_base_depth_from_base_obj(base_obj)
    base_obj.destruct()
    local player_color = get_decoration_for_guid(base_obj.getGUID(), 'player_color')
    local command_color = get_decoration_for_guid(base_obj.getGUID(), 'command_color')
    local is_red_player = (player_color == "RED")

    local new_obj = spawn_base(dismounted_definition, pos, y_rotation,
      is_red_player, command_color)

    -- have the new front edge lineup with the old front edge
    local new_depth = get_base_depth_from_base_obj(new_obj)
    local depth_difference_mm = old_depth - new_depth;
    local depth_difference_inches = from_mm_to_in(depth_difference_mm)
    print("depth_difference_mm=", depth_difference_mm)
    print("depth_difference_inches=", depth_difference_inches)
    move_base_forward(new_obj, depth_difference_inches/2.0)

    local new_name = new_obj.getName()
    print_info("Dismounted " .. old_name .. " as " .. new_name)
  end)
end

function add_context_menu_base(base_obj)
    base_obj.clearContextMenu()
    local definition = get_base_definition_from_base_obj(base_obj)
    if definition == nil then
      -- no context menu for proxy bases, they are not part of an army.
      return
    end
    base_obj.addContextMenuItem("Turn around", function()
        turn_around_base(base_obj)
    end)
    base_obj.addContextMenuItem("Fall back", function()
        push_back(base_obj)
    end)
    base_obj.addContextMenuItem("Pursue", function()
        push_forward(base_obj)
    end)
    base_obj.addContextMenuItem("Right turn to face", function()
        right_turn_to_face(base_obj)
    end)
    base_obj.addContextMenuItem("Left turn to face", function()
        left_turn_to_face(base_obj)
    end)
    base_obj.addContextMenuItem("Evade", function()
        evade(base_obj)
    end)
    base_obj.addContextMenuItem("Panic", function()
        panic(base_obj)
    end)
   base_obj.addContextMenuItem("Killed", function()
     local ok
     local error
       ok,error = pcall( function()
        base_killed(base_obj)
      end)
      if not ok then
        print_error("base_killed: " .. tostring(error))
      end
    end)
    add_dismount_context_menu_base(base_obj)
    base_obj.addContextMenuItem('Show edges', function()
        show_edges(base_obj)
    end)
    base_obj.addContextMenuItem("Make General", function()
        make_general(base_obj)
    end)
    base_obj.addContextMenuItem('Toggle tool tips', function()
        toggle_tool_tips()
    end)
end

function add_context_menu_table(table_obj)
    table_obj.addContextMenuItem('Toggle BUA fire/ZOC', function()
        show_gizmo_bua()
    end)
end


function on_clone(source_obj, new_obj)
    local name = source_obj.getName()
    print_info(name .. " has been duplicated.")
    local base_definition = get_base_definition_from_guid(source_obj.getGUID())
    if base_definition == nil then
      print_error("Base definition is nil")
      return
    end
    local base_name = 'base ' .. base_definition['name'] .. ' #' .. g_base_index
    g_base_index = g_base_index + 1
    new_obj.setName(base_name)
    g_bases[base_name] = {
        tile = g_bases[name]['tile'],
        is_red_player = g_bases[name]['is_red_player']
    }
    new_obj.clearContextMenu()
    g_decorations[new_obj.getGUID()] = deep_copy(g_decorations[source_obj.getGUID()])
    add_context_menu_base(new_obj)
end

function onObjectSpawn(new_obj)
    local name = new_obj.getName()
    local my_guid = new_obj.getGUID()
    if name ~= nil and str_starts_with(name, "base") then
        -- Check if the name as an old one
        local all_objs = getAllObjects()
        local bases = filter_bases(all_objs)
        local found_base = nil
        for _,base in ipairs(bases) do
            if base.getName() == name and base.getGUID() ~= my_guid then
                found_base = base
                break
            end
        end

        if found_base ~= nil then
            on_clone(found_base, new_obj)
        else
          add_context_menu_base(new_obj)
        end
    end
end


-- Always return the same figure name
function static_model_iterator(model_name)
  return function ()
    return model_name
  end
end

-- Return the figures in sequence
function fixed_model_iterator(fixed_models)
  local i = 0
  return function ()
    i = i + 1
    return fixed_models[i]
  end
end

-- Return a random figure
function random_model_iterator(random_models)
  if random_models == nil then
    print_error("random_models is nil")
    return nil
  end
  local nb = tlen(random_models)
  return function ()
      local i = math.random(1, nb)
      return random_models[i]
  end
end


-- Appendix A
-- @param troop_type, e.g. archers
-- @return Number of figures that should be on the base,
function figures_per_base(troop_type)
  if troop_type == "Archers" then
    return 4
  end
  if troop_type == "Bow Levy" then
    return 3
  end
  if troop_type == "Light Foot" then
    return 3
  end
  if troop_type == "Light Spear" then
    return 3
  end
  if troop_type == "Rabble" then
    return 3
  end
  if troop_type == "Raiders" then
    return 4
  end
  if troop_type == "Skirmishers" then
    return 2
  end
  if troop_type == "Warband" then
    return 3
  end

  if troop_type == "Elite Foot" then
    return 4
  end
  if troop_type == "Heavy Foot" then
    return 4
  end
  if troop_type == "Horde" then
    return 7
  end
  if troop_type == "Pavisiers" then
    return 8
  end
  if troop_type == "Pikes" then
    return 4
  end
  if troop_type == "Spears" then
    return 4
  end
  if troop_type == "Warriors" then
    return 4
  end


  if troop_type == "Bad Horse" then
    return 3
  end
  if troop_type == "Elite Cavalry" then
    return 3
  end
  if troop_type == "Horse Bow" then
    return 2
  end
  if troop_type == "Javelin Cavalry" then
    return 2
  end
  if troop_type == "Knights" then
    return 3
  end

  if troop_type == "Cataphracts" then
    return 4
  end

  print_error("No default number of figures for " .. troop_type)
  return 0
end


function model_from_model_name(model_name)
  if model_name == nil then
    return nil
  end
  local model = _G[model_name]
  if model == nil then
    model = g_models[model_name]
  end
  return model
end

-- Randomly choose meshes
-- model_name: Name of the model that determines the meshes that
--   are available.
-- how_many:  How many meshes to choose.
function meshes_from_model_name(model_name, how_many)
  local meshes = {}
  local model = model_from_model_name(model_name)
  if model == nil then
    print_debug("No model: " .. tostring(model_name))
    return meshes
  end
  local mesh = model['mesh']
  if nil == mesh then
    return meshes
  end
  return calculate_random_meshes(how_many, mesh)
end

-- Get the figure object,
-- base_obj: Object that will have the model attached to it.
-- model_name: Name of the figure to add. e.g. 'troop_norman_knight_lance_pennat'.
--  The string is used to workaround having to forward declare the object.
-- model_pos: location on the base to place the model. Base center is (0,0,0)
-- model_y_rotation_degrees: Rotation of the model on the base.  Towards front is zero.  In degrees.
-- is_red_player:
-- mesh: default to use for the model for the texture.
function get_model_obj(base_obj, model_name, model_pos, model_y_rotation_degrees, is_red_player, mesh)
  local pos = base_obj.getPosition()
  local relative_pos = {
      x = pos['x'] + model_pos['x'],
      y = pos['y'] + model_pos['y'],
      z = pos['z'] + model_pos['z']
  }
  if this_model_name ~= nil then
    if _G[this_model_name]['customasset'] ~= nil then
        local soldier_obj = spawn_asset(model_name, relative_pos, model_y_rotation_degrees)
        return soldier_obj
    end
    -- The object has non-fixed models, so we use any of the
    -- randomly selected meshes
    local soldier_obj = spawn_model(model_name, relative_pos,
        model_y_rotation_degrees, minimal_collider, is_red_player, nil, mesh)
    return soldier_obj
  end

  -- Now we have fixed models, so we use the corresponding one
  -- Except that fixed models may use assets instead of meshes!
  if _G[model_name]['customasset'] ~= nil then
      local soldier_obj = spawn_asset(model_name, relative_pos,
        model_y_rotation_degrees)
      return soldier_obj
  end

  local meshes = _G[model_name]['mesh']
  mesh = random_element(meshes)
  local soldier_obj = spawn_model(model_name, relative_pos,
      model_y_rotation_degrees, minimal_collider, is_red_player,
      nil, mesh)
  return soldier_obj
end

-- base_obj: Object that will have the model attached to it.
-- model_name: Name of the figure to add. e.g. 'troop_norman_knight_lance_pennat'
-- model_pos: location on the base to place the model. Base center is (0,0,0)
-- model_y_rotation_degrees: Rotation of the model on the base.  Towards front is zero.  In degrees.
-- is_red_player:
-- mesh: default to use for the model for the texture.
function add_model(base_obj, model_name, model_pos, model_y_rotation_degrees, is_red_player, mesh)
  local soldier_obj = get_model_obj(base_obj, model_name, model_pos,
    model_y_rotation_degrees, is_red_player, mesh)
  base_obj.addAttachment(soldier_obj)
end

function add_overlay_models(base_obj, model_definition, is_red_player)
  for _,overlay_model in pairs(model_definition['overlay_models']) do
    local model_name = overlay_model['model_data']
    if model_name == nil then
      print_error("model_name is nil")
      return
    end
    local model_pos = overlay_model['position']
    if model_pos == nil then
      model_pos = {x=0,y=0,z=0}
    else
      model_pos = deep_copy(model_pos)
    end
    local model_y_rotation_degrees = overlay_model['rotation']
    if model_y_rotation_degrees == nil then
      model_y_rotation_degrees = 0
    end
    local scale = overlay_model['scale']
    if scale == nil then
      scale = 1
    end

    -- Add the height of the base to the spawned object.
    model_pos['y'] = model_pos['y'] + g_base_height_inches

    local mesh = nil
    local model_obj = get_model_obj(base_obj, model_name, model_pos,
      model_y_rotation_degrees, is_red_player, mesh)
    model_obj.scale(scale)
    base_obj.addAttachment(model_obj)
  end
end

-- model_definition: definition of how the base should look like
-- Return iterator that will select a figure to add to a base.
function get_model_iterator(model_definition)
  local model_name = model_definition['model_data']
  if model_name ~= nil then
    return static_model_iterator(model_name)
  end
  if model_definition['fixed_models'] ~= nil then
    return fixed_model_iterator(model_definition['fixed_models'])
  end
  if model_definition['random_models'] ~= nil then
    return random_model_iterator(model_definition['random_models'])
  end
  print_error("model definition not understood")
  return nil
end

-- add models to base object when the models are to be placed in
-- a random localtion on the base to show that they are in a loose order.
--
-- base_name: Name of the base, e.g. "Skirmishers"
-- model_definition: definition of how the base should look like
-- base_definition: definition of base we are constructing
-- base_obj: base object
-- is_player_red: red or blue base
-- pos Location of the base.
-- y_rotation: rotation of the base
function add_loose_models(base_name, model_definition, base_definition, base_obj, is_red_player, pos, y_rotation)
  local n = model_definition['n_models']
  if n == nil then
    n = figures_per_base(base_definition.name)
  end
  if (n == 0) then
      base_obj.setRotation({0, y_rotation, 0})
      base_obj.auto_raise = false
      return
  end

  local depth = get_depth_base(model_definition['base'])
  local half_depth = depth / 2
  local half_width = g_base_width_in_inches / 2

  local rows = 1
  local columns = n
  if n > 4 then
      rows = math.floor(math.sqrt(n))
      columns = math.ceil(n/rows)
  end

  local model_name = model_definition['model_data']
  local meshes = meshes_from_model_name(model_name, n)

  local figure_iter = get_model_iterator(model_definition)
  if (figure_iter == nil) then
    return  nil
  end

  -- A cell is the location where a figure can be placed
  if columns < 4 then
    columns = columns + 1
  end
  local column_width = g_base_width_in_inches / (columns + 1)
  local row_depth = depth / (rows + 1)
  local nb_cells = rows * columns
  local cells = {}
  for cell_nb=1,nb_cells do
    local column = (cell_nb - 1) % columns + 1
    local row = math.floor((cell_nb - 1) / columns) + 1
    local x = column * column_width - half_width
    local z = row * row_depth - half_depth
    cells[cell_nb] = {
      column = column,
      row = row,
      x = x,
      z = z
    }
  end

  for i=1,n do
    local index = math.random(1, #cells)
    local cell = cells[index]
    table.remove(cells, index)

    local model_y_rotation_degrees = math.random(0, 100) - 50
    local random_x = random_float(-g_max_loose_spawn, g_max_loose_spawn)
    local random_z = random_float(-g_max_loose_spawn, g_max_loose_spawn)

    local model_pos = {
          x = cell.x + random_x,
          y = g_base_height_inches / 2,
          z = cell.z + random_x
      }

    local this_model_name = figure_iter()
    add_model(base_obj, this_model_name, model_pos,
        model_y_rotation_degrees, is_red_player, meshes[i])
  end

  base_obj.setRotation({0, y_rotation, 0})
  base_obj.auto_raise = false
end

-- add models to base object
-- base_name: Name of the base, e.g. "Camp"
-- model_definition: definition of how the base should look like
-- base_definition: definition of base we are constructing
-- base_obj: base object
-- is_player_red: red or blue base
-- pos Location of the base.
-- y_rotation: rotation of the base
function add_models(base_name, model_definition, base_definition, base_obj, is_red_player, pos, y_rotation)

  if  model_definition['overlay_models'] ~= nil then
    add_overlay_models(base_obj, model_definition, is_red_player)
    return
  end
  if model_definition['loose'] == true then
    add_loose_models(base_name, model_definition, base_definition, base_obj,
      is_red_player, pos, y_rotation)
    return
  end

  local n = model_definition['n_models']
  if n == nil then
    n = figures_per_base(base_definition.name)
  end
  if (n == 0) then
      base_obj.setRotation({0, y_rotation, 0})
      base_obj.auto_raise = false
      return
  end

  local depth = get_depth_base(model_definition['base'])
  local half_depth = depth / 2
  local half_width = g_base_width_in_inches / 2

  local rows = 1
  local columns = n
  if n > 4 then
      rows = math.floor(math.sqrt(n))
      columns = math.ceil(n/rows)
  end

  local column_width = g_base_width_in_inches / (columns + 1)
  local row_depth = depth / (rows + 1)

  local model_name = model_definition['model_data']

  local meshes = meshes_from_model_name(model_name, n)

  local figure_iter = get_model_iterator(model_definition)
  if (figure_iter == nil) then
    return  nil
  end

  for i=1,n do
      local column = (i - 1) % columns + 1
      local row = math.floor((i - 1) / columns) + 1

      local model_y_rotation_degrees
      if str_has_substr(base_name, 'Camp') then
          model_y_rotation_degrees = 0
      else
        model_y_rotation_degrees = math.random(0, 40) - 20
      end

      local model_pos = {
          x = column * column_width - half_width,
          y = g_base_height_inches / 2,
          z = row * row_depth - half_depth
      }

      local this_model_name = figure_iter()
      add_model(base_obj, this_model_name, model_pos,
        model_y_rotation_degrees, is_red_player, meshes[i])
  end

  base_obj.setRotation({0, y_rotation, 0})
  base_obj.auto_raise = false
end

-- Spawn the elephant screen counter and snap it to the top of the base.
-- base_obj: base the counter will be on top of.
-- base_definition: Definition for the base that the counter will be for.
-- base_pos: Location of the base that the counter should be on top of.
-- is_red_player: Is the player red or blue
-- command_color: color of the command within the players army.
function spawn_elephant_screen_counter(base_obj, base_definition, base_pos, is_red_player, command_color)
  local counter_definition_id = base_definition['id'] .. "_elephant_screen_counter"
  local counter_definition = g_base_definitions[counter_definition_id]
  if counter_definition == nil then
    print_err("No base definition for " .. tostring(counter_definition_id))
    return nil
  end
  counter_definition['elephant_screen'] = nil

  local counter = spawn_base(counter_definition, base_pos, 0, is_red_player, command_color)
  if counter == nil then
    print_err("spawn_elephant_screen_counter failed " .. tostring(counter_definition_id))
    return nil
  end

  local transform_moving = calculate_transform(counter)
  local transform_resting = calculate_transform(base_obj)

  snap_to_base(counter, transform_moving, base_obj, transform_resting, 'infront')
end

function base_highlight(base_obj, command_color)
  local forever = 86400 -- duration for highlght
  if command_color == 'None' then
    return
  end
  if command_color == 'Blue' then
    base_obj.highlightOn({r=0,g=0,b=1}, forever)
    return
  end
  if command_color == 'Green' then
    base_obj.highlightOn({r=0.1,g=1,b=0.4}, forever)
    return
  end
  if command_color == 'Purple' then
    base_obj.highlightOn({r=0.3,g=0,b=0.7}, forever)
    return
  end
  if command_color == 'Red' then
    base_obj.highlightOn({r=1,g=0,b=0}, forever)
    return
  end
  if command_color == 'Orange' then
    base_obj.highlightOn({r=1,g=0.5,b=0}, forever)
    return
  end
  if command_color == 'Yellow' then
    base_obj.highlightOn({r=1,g=1,b=0}, forever)
  end
end


-- Get the tile to place the figures on
-- base_definition: Description on how the base should look like.
-- return: string for the tile e.g. "tile_grass_40x20"
function get_model_base_tile(base_definition)
  local model_base_name = base_definition['base']
  if model_base_name ~= nil then
    return model_base_name
  end
  -- get the base name from the army.
  local army_id = base_definition['army_id']
  local army_data = army[ army_id ]['data']
  local style = army_data['base']
  if style == nil then
    print_debug("army has no default base.")
    style = "tile_grass"
  end
  local depth = get_base_depth_from_base_definition(base_definition)
  local width = get_base_width_from_base_definition(base_definition)
  local model_base_name = style .. "_" .. tostring(width) .. "x" .. tostring(depth)
  return model_base_name
end

-- base: base_definition base_definition
-- pos: position where the base will be located
-- y_rotation: in degrees
-- is_red_player: Will the base belong to the red player
-- common_color: color of the base edge, who ows the base.
function spawn_base(base_definition, pos, y_rotation, is_red_player, command_color)
    print_debug('Spawning base #' .. g_base_index)
    local overriden_tex = nil
    if base_definition['ignore_terrain'] == nil then
        local type = from_toggle_number_to_table_type(g_game_settings["table type"])
        if tables[type] == nil then
            type = 'grass'
        end

        if is_red_player then
            overriden_tex = tables[type]['red_player_base_tex']
        else
            overriden_tex = tables[type]['blue_player_base_tex']
        end
    end

    local model_definition = get_a_model_definition(base_definition)

    --Get the tile to place the models on
    local model_base_name = model_definition['base']
    if model_base_name == nil then
       model_definition['base'] = get_model_base_tile(base_definition)
    end
    model_base_name = model_definition['base']
    if model_base_name == nil then
      print_error("no base for model definition")
      return
    end

    local model_base = _G[model_base_name]
    if model_base == nil then
      print_error("No variable defined for " .. tostring(model_base_name))
    end
    -- model texture overides other textures
    local texture_name
    if is_red_player then
      texture_name = 'player_red_tex'
    else
      texture_name = 'player_blue_tex'
    end
    local model_texture = model_base[texture_name]
    if (nil ~= model_texture) then
      overriden_tex = model_texture
    end

    local base_obj = spawn_model(model_base_name, pos, 0, nil, is_red_player, overriden_tex)
    base_obj.dynamic_friction = 1.0
    base_obj.static_friction = 1.0

    if base_definition['name'] == nil then
        print_error('One of the base definitions of this army has no name! Please report to us so we can fix it asap')
        return
    end
    local base_name = 'base ' .. base_definition['name'] .. ' #' .. g_base_index
    base_obj.setName(base_name)

    g_base_index = g_base_index + 1
    g_bases[base_name] = {
        tile = model_definition['base'],
        is_red_player = is_red_player
    }

    base_highlight(base_obj, command_color)

    local base_definition_name = base_definition['id']
    if base_definition_name == nil then
        -- LEGACY
        base_definition_name = base_definition['base_definition_name']
    end

    local player_color
    if is_red_player then
      player_color = "RED"
    else
      player_color = "BLUE"
    end
    set_decoration_for_obj(base_obj, "base_definition_name", base_definition_name)
    set_decoration_for_obj(base_obj, "command_color", command_color)
    set_decoration_for_obj(base_obj, "player_color", player_color)

    add_models(base_name, model_definition, base_definition, base_obj,
        is_red_player, pos, y_rotation)
    update_tool_tip(base_obj)
    add_context_menu_base(base_obj)

    if base_definition['elephant_screen'] then
      spawn_elephant_screen_counter(base_obj, base_definition, pos, is_red_player, command_color)
    end

    set_last_snapshot()

    return base_obj
end

troop_type_to_plain_model_tile_name['Pavisiers']='tile_plain_Pavisiers'
troop_type_to_plain_model_tile_name['Camp']='tile_plain_Camp'

troop_type_to_plain_model_tile_name['Pavisiers General']='tile_plain_Pavisiers_Gen'
troop_type_to_plain_model_tile_name['Camp General']='tile_plain_Camp_Gen'

troop_type_to_plain_model_tile_name['Elephant Screen']='tile_plain_El_Screen'

-- Return name (a string) of the variable that is plain tile for
-- the base definition
function get_plain_model_tile_name(base_definition)
  if base_definition.troop_type == 'Camp' then
    if base_definition.pack_train then
      return 'tile_plain_Trains_And_Herds_Donkeys'
    end
    if base_definition.standard_wagon then
      return 'tile_plain_Standard_Wagon'
    end
    if base_definition.fortified_camp then
      return 'tile_plain_Fortified_Camp'
    end
  end

  -- Check if the plain tile for the base has been generated by generate_plain_tiles.py
  if nill == base_definition.troop_type then
    print_error("Troop type is missing")
    return nil
  end
  code = "tile_plain_" .. (base_definition.troop_type:gsub(' ','_'))
  if base_definition.general then
    code = code .. "_Gen"
  end
  if base_definition.mobile_infantry and base_definition.dismount_as ~= nil then
      code = code .. "_MI"
  end
  if _G[code] then
    return code
  end


  if nil ~= base_definition['prepared_defenses'] then
    return 'tile_plain_Prepared_defenses'
  end
  local name = base_definition.name
  if base_definition.light_camelry then
    return get_light_camelry_plain_tile(base_definition.general)
  end
  local tile = troop_type_to_plain_model_tile_name[name]
  if tile == nil then
    print_error("No plain tile for " .. tostring(name))
    table_print(base_definition)
    -- TODO choose something that is an obvious error -- like a plain tile with no info.
    return  'tile_grass_40x15'
    end
    return tile
end


function get_plain_base_model_definition(base_definition)
  -- Use a plain base.
  local tile_name = get_plain_model_tile_name(base_definition)
  local base_def_name = base_definition.name
  return {
      name = base_def_name,
      ignore_terrain = 'false',
      n_models = 0,
      base = tile_name,
  }
end

-- Get a model definition, base and figures, that can be used to represent
-- a base definition.
function get_a_model_definition(base_definition)
  if nil ~= base_definition.prepared_defenses then
    return {
      name = base_definition.name,
      ignore_terrain = 'false',
      n_models = 0,
      base = "model_prepared_defenses_2d",
    }
  end

  if  g_use_plain_bases then
    return get_plain_base_model_definition(base_definition)
  end
  -- try to use models
  local id = base_definition.id
  if nil ~= id then
    if g_models[ id ] ~= nil then
      -- choose a random model definition
      local models = g_models[ id ]
      local index = math.random(1, #models)
      local model = models[index]
      if model == nil then
        print_error("model is nil.  id=" .. tostring(id) .. " index=" .. tostring(index))
        return get_plain_base_model_definition(base_definition)
      end
      return model
     end
  end

  if  base_definition.n_models ~= nil then
    -- base definition is model definition,
    -- Used for proxy bases
    return base_definition
  end

  -- default to plain base if no model is available.
  return get_plain_base_model_definition(base_definition)
end


-- Get the base definintion from the name of the base definition
function get_base_definition_from_name(base_definition_name)
  if nil == base_definition_name then
    return nil
  end
  local base_definition = g_base_definitions[base_definition_name]
  if nil ~= base_definition_name then
      return base_definition
  end

  base_definition = _G[base_definition_name]
  if nil ~= base_definition_name then
      return base_definition
  end

  return nil
end

-- Get the definition for a base
-- base_data:  If string is the name of the variable holding the definition,
--    otherwise it is the definition.
-- return: table defining the base
function get_base_definition(base_data)
  if type(base_data) ~= "string" then
    return base_data
  end

  local definition = g_base_definitions[base_data]
  if definition ~= nil then
    return definition
  end

  -- Legacy
  -- The string refers to the name of the variable that
  -- defines the base.
  definition = _G[base_data]
  if nil ~= definition then
    definition.base_definition_name = base_data
    return definition
  end

  print_error("base definition missing: " .. tostring(base_data))
  return nil
end

function get_undeployed_bag(is_red_player)
  if is_red_player then
    return get_object_by_name("Red undeployed")
  else
    return get_object_by_name("Blue undeployed")
  end
end

function move_base_to_undeployed(base_obj)
  local is_red =  is_base_red_player(base_obj)
  local bag = get_undeployed_bag(is_red)
  if bag == nil then
    print_error("bag is nil")
    return
  end
  bag.putObject(base_obj)
end

-- Have the tablet show the Meshwesh page for the army.
function set_tablet(is_red_player, army)
  local table_name
  if is_red_player then
    tablet_name = "red tablet"
  else
    tablet_name = "blue tablet"
  end
  local tablet = get_object_by_name(tablet_name)
  if tablet == nil then
    print_error("Unable to find tablet " .. tablet_name)
    return
  end

  local url = "https://meshwesh.wgcwar.com/armyList/" ..  army['data']['id'] .. "/explore"
  tablet.Browser.url = url
  print_info(url)
end

function is_token_obj(obj)
  if true == get_decoration_for_obj(obj, "token") then
    return true
  else
    return false
  end
end


-- Spawn a token that can be used to buy a battle card
-- name: name of the token.
-- pos: location token will be spawned
-- player: "RED" or "BLUE"
function spawn_battle_card_token(name, pos, player)
  local object = spawnObjectData({
    data = {
        Name = "Custom_Tile",
        Transform = {
            posX = pos['x'],
            posY = pos['y'],
            posZ = pos['z'],
            rotX = 0,
            rotY = 180,
            rotZ = 0,
            scaleX = 0.7602123,
            scaleY = 1,
            scaleZ = 0.7602123
        },
        ColorDiffuse = {
            r = 0.3,
            g = 0.5,
            b = 0.8
        },
        CustomImage = {
          ImageURL = g_assets[name],
          ImageSecondaryURL = g_assets["counter_background"],
          ImageScalar =  1.0,
          WidthScale = 0.0,
          CustomTile = {
           Type = 2,
           Thickness = 0.197222441,
           Stackable = false,
           Stretch = false
       }
     },
    }    })
    set_decoration_for_obj(object, "token", true)
    set_decoration_for_obj(object, "player_color", player)

    return object
end


-- Spawn a token that can be used to buy the Ambush battle card.
-- pos: location of the token
-- player: RED or BLUE
function spawn_ambush_token(pos, player)
  local object = spawn_battle_card_token("token_ambush", pos, player)
  object.setName("Ambush")
  set_decoration_for_obj(object, "token_ambush", true)
end

-- Spawn a token that can be used to buy the No Camp battle card.
-- pos: location of the token
-- player: RED or BLUE
function spawn_no_camp_token(pos, player)
  local object = spawn_battle_card_token("token_no_camp", pos, player)
  object.setName("No Camp")
  set_decoration_for_obj(object, "token_no_camp", true)
end


-- Spawn a token that can be used to buy the Charge Through battle card.
-- pos: location of the token
-- player: RED or BLUE
function spawn_charge_through_token(pos, player)
  local object = spawn_battle_card_token("token_charge_through", pos, player)
  object.setName("Charge Through")
  set_decoration_for_obj(object, "token_charge_through", true)
end

-- Spawn a token that can be used to buy the Hold The Line battle card.
-- pos: location of the token
-- player: RED or BLUE
function spawn_hold_the_line_token(pos, player)
  local object = spawn_battle_card_token("token_hold_the_line", pos, player)
  object.setName("Hold The Line")
  set_decoration_for_obj(object, "token_hold_the_line", true)
end

-- Given an army object data, spawns it on the center of the table.
-- Hope nothing is in there and that all data is correct because this doesn't
-- validate
-- army: Army with base g_base_definitions
-- is_red_player: Boolean
-- command_color: color within the players troops, e.g. "Orange"
-- army_nb: Army number for the player, main army is 1, allies are 2 or 3
function spawn_army(army, is_red_player, command_color, army_nb)
    local player
    if is_red_player then
      player = "RED"
    else
      player = "BLUE"
    end

    g_movement_reporting_enabled = false

    distance_between_armies = (g_max_bases_row+1) * g_base_width_in_inches
    assert(nil ~= army)
    local army_name = army.data.name
    assert(nil ~= army_name)
    math.randomseed(os.time())

    local z_pos_0 = g_spawn_from_center_in
    local y_rotation = 180
    if is_red_player then
        z_pos_0 = g_spawn_from_center_in * -1
        y_rotation = 0
    end

    local z_pos = 0.5
    if is_red_player then
        z_pos = z_pos * -1
    end

    local z_pos_modifier = - -1
    if is_red_player then
        z_pos_modifier = -1 * z_pos_modifier
    end

    local army_charge_through_limit_fulfilled = false
    local army_hold_the_line_limit_fulfilled = false
    local column = 0
    local row = 0
    local last_troop_option = nil
    local row_wrap_bonus = 0
    for base_id,base_data  in pairs(army) do
        if base_id ~= 'data' then
            local base_definition = get_base_definition(base_data)
            if nil ~= base_definition then
              if base_definition['min'] == nil then
                base_definition['min'] = 0
              end
              if base_definition['max'] == nil then
                base_definition['max'] = 1
              end

              if base_definition['troop_option_id'] ~= last_troop_option then
                row = row + row_wrap_bonus
                row = row + 1
                column = 0
                row_wrap_bonus = 0
              else
                column = column + 0.5
              end
              if 0 == base_definition['min'] then
                column = column + 0.5
              end
              for copy=1,base_definition['max'] do

                local row_z_pos = (g_base_width_in_inches + 0.75) * (1 + row) * z_pos_modifier + z_pos_0

                local location = {
                    x = g_offset_deployment_x + column * g_base_width_in_inches + (army_nb - 1 ) * distance_between_armies,
                    y = g_base_height_tabletop + g_table_thickness + g_base_height_inches / 2,
                    z = row_z_pos
}
                local base_obj = spawn_base(base_definition, location, y_rotation, is_red_player, command_color)
                last_troop_option = base_definition['troop_option_id']
                if base_definition['dismounted_from'] ~= nil then
                  -- Move the base into the undeployed bag
                  move_base_to_undeployed(base_obj)
                else
                  -- calculate the position for the next base.
                  if copy == base_definition['min'] then
                    column = column + 0.5
                  end
                  column = column + 1
                  if column >= g_max_bases_row then
                    column = 0
                    row = row + 1
                    row_wrap_bonus = 0.5
                  end
                end
              end
            end
        local row_z_pos = (g_base_width_in_inches + 0.75) * (1 + row) * z_pos_modifier + z_pos_0
        if base_definition.charge_through and not army_charge_through_limit_fulfilled then
          for i=1,2 do
            local location = {
                x = g_offset_deployment_x + column * g_base_width_in_inches + (army_nb - 1 ) * distance_between_armies,
                y = g_base_height_tabletop + g_table_thickness + g_base_height_inches / 2,
                z = row_z_pos}
            spawn_charge_through_token(location, player)
            column = column + 1
          end
          army_charge_through_limit_fulfilled = true
        end
        if base_definition.hold_the_line and not army_hold_the_line_limit_fulfilled then
          for i= 1,3 do
            local location = {
                x = g_offset_deployment_x + column * g_base_width_in_inches + (army_nb - 1 ) * distance_between_armies,
                y = g_base_height_tabletop + g_table_thickness + g_base_height_inches / 2,
                z = row_z_pos}
            spawn_hold_the_line_token(location, player)
            column = column + 1
          end
          army_hold_the_line_limit_fulfilled = true
        end

      end
    end
    column = 0
    row = row + 1
    local row_z_pos = (g_base_width_in_inches + 0.75) * (1 + row) * z_pos_modifier + z_pos_0
    if army.data.ambush  then
      local location = {
          x = g_offset_deployment_x + column * g_base_width_in_inches + (army_nb - 1 ) * distance_between_armies,
          y = g_base_height_tabletop + g_table_thickness + g_base_height_inches / 2,
          z = row_z_pos}
      spawn_ambush_token(location, player)
      column = column + 1
    end
    if army.data.no_camp  then
      local location = {
          x = g_offset_deployment_x + column * g_base_width_in_inches + (army_nb - 1 ) * distance_between_armies,
          y = g_base_height_tabletop + g_table_thickness + g_base_height_inches / 2,
          z = row_z_pos}
      spawn_no_camp_token(location, player)
      column = column + 1
    end

    update_tool_tips()
    print_important('Army deployed: ' .. army.data.name )
    g_movement_reporting_enabled = true
end


function get_author_tile(tilename)
    local tile = _G[tilename]
    return tile['author']
end

function get_author_model(modelname)
    local model = _G[modelname]
    return model['author']
end

function get_author_base(base_definition)
  -- TODO broken for now due to meshwesh integration.
  -- Should return a set of authors that have made a model that
  -- could be used
  return "TODO"
    --if base['n_models'] == 0 then
    --     return get_author_tile(base['base'])
    -- end
    -- local model = base['model_data']
    -- if model == nil then
    --     model = base['fixed_models'][1]
    -- end
    -- return get_author_model(model)
end


function get_first_book_with_models()
    for book_name, book_armies in pairs(armies) do
        if book_has_an_army_with_models(book_name) then
            return book_name
        end
    end
    return nil
end



-- Provide an iterator to walk through a sorted table
-- t: Table to sort
-- f: Function to use to sort.
function pairsByKeys (t, f)
    local a = {}
    for n in pairs(t) do
        table.insert(a, n)
    end
    table.sort(a, f)
    local i = 0      -- iterator variable
    local iter = function ()   -- iterator function
        i = i + 1
        if a[i] == nil then
            return nil
        else
          return a[i], t[a[i]]
        end
    end
    return iter
end


g_current_table = nil
function spawn_table_obj(model_url, texture_array_urls)
    local obj = spawnObject({
        type = 'Custom_Model',
        position = { x = 0, y = g_base_height_tabletop, z = 0},
        rotation = { x = 0, y = 0, z = 0},
        scale = { x = 1, y = 1, z = 1},
        sound = false,
        snap_to_grid = false,
        callback_function = function(obj)
            g_current_table = obj.getGUID()
        end
    })
    local tex_index = math.random(1, #texture_array_urls)
    obj.setCustomObject({
        mesh = model_url,
        diffuse = texture_array_urls[tex_index],
        material = 1,
        cast_shadows = false,
        specular_sharpness = 0,
        specular_intensity = 0,
        freshnel_strength = 0
    })
    if is_large then
        print_important('Large table spawned')
    else
        print_important('Table spawned')
    end

    add_context_menu_table(obj)
    obj.setLock(true)
end


function _is_base_to_have_terrain(base_obj)
  if is_base_prepared_defenses(base_obj) then
    return false
  end
  local name = base_obj.getName()
  if name == nil then
    return false
  end
  if g_bases[name] == nil then
    return false
  end
  if str_has_substr(g_bases[name]['tile'], 'plain') then
    return false
  end
  return true
end


function change_bases_to_terrain(terrain_type)
    print_debug('Changing bases to ' .. terrain_type)
    local all_objs = getAllObjects()
    local bases = filter_bases(all_objs)
    for _,base in ipairs(bases) do
      if _is_base_to_have_terrain(base) then
        local name = base.getName()
        print_debug('Changing ' .. name)
        local is_red = g_bases[name]['is_red_player']
        local tex = tables[terrain_type]['blue_player_base_tex']
        if is_red then
          tex = tables[terrain_type]['red_player_base_tex']
        end
        local custom = base.getCustomObject()
        custom['diffuse'] = tex
        base.setCustomObject(custom)
        g_ignore_next_delete[name] = true
        base.reload()
      end
    end
    Wait.frames(function()
        local all_objs = getAllObjects()
        local bases = filter_bases(all_objs)
        for _,base in ipairs(bases) do
            local name = base.getName()
            if g_bases[name] ~= nil then
                add_context_menu_base(base)
            end
        end
    end, 1)
end


function spawn_model(troop_name, pos, added_y_axis_rotation, collider, is_player_red, overridden_tex, overridden_mesh, locked)
    if locked == nil then
      locked = false
    end

    -- Better pray that the input name actually exists! lol
    local model_data = _G[troop_name]
    if model_data == nil then
      print_error("Unable to spawn model, variable not defined: " .. tostring(troop_name))
    end

    local texture = overridden_tex
    if texture == nil then
        texture = model_data['player_blue_tex']
        if is_player_red then
            texture = model_data['player_red_tex']
        end

        -- Vegetation etc does not have that kind of player texture
        -- they are global
        if texture == nil then
            texture = model_data['texture']
        end
    end

    local selected_mesh = overridden_mesh
    if selected_mesh == nil then
        local meshes = model_data['mesh']
        local mesh_index = math.random(1, #model_data['mesh'])
        selected_mesh = meshes[mesh_index]
    end

    local spawn_data = get_spawn_model(pos,
        model_data['rotation'],
        model_data['height_correction'],
        model_data['scale'],
        selected_mesh,
        texture,
        collider)
    spawn_data['spawn']['rotation']['y'] = spawn_data['spawn']['rotation']['y'] + added_y_axis_rotation
    local obj = spawnObject(spawn_data['spawn'])
    obj.setLock(locked)
    obj.setCustomObject(spawn_data['custom_obj_attrs'])

    return obj
end

function spawn_asset(asset_name, pos, added_y_axis_rotation)
    print_debug('Spawning asset ' .. asset_name)
    if _G[asset_name]['rotation'] then
        added_y_axis_rotation = added_y_axis_rotation + _G[asset_name]['rotation']
    end

    local obj = spawnObject({
        type = 'Custom_Assetbundle',
        position = pos,
        rotation = { x = 0, y = added_y_axis_rotation, z = 0},
        scale = { x = 1, y = 1, z = 1 },
        sound = false,
        snap_to_grid = false
    })
    obj.setCustomObject({
        assetbundle = _G[asset_name]['customasset']
    })
    return obj
end

function calculate_random_meshes(how_many, meshes_available)
    if type(how_many) ~= "number" then
      print_error("how_many must be number not " .. type(how_many) .. ": ".. tostring(how_many))
      return nil
    end
    local aux = {}
    local meshes = {}
    for i = 1, how_many do
        if #aux == 0 then
            for k,v in pairs(meshes_available) do
                aux[k] = v
            end
        end
        local index = math.random(1, #aux)
        meshes[i] = aux[index]
        table.remove(aux, index)
    end
    return meshes
end

function get_spawn_model(pos, rotation_correction, height_correction, model_scale, model_mesh, model_diffuse, collider_if_exists)
    return {
        spawn = {
            type = 'Custom_Model',
            position = { x = pos['x'], y = pos['y'] + height_correction, z = pos['z']},
            rotation = { x = 0, y = rotation_correction, z = 0},
            scale = { x = model_scale, y = model_scale, z = model_scale},
            sound = false,
            snap_to_grid = false
        },
        custom_obj_attrs = {
            mesh = model_mesh,
            diffuse = model_diffuse,
            material = 3,
            collider = collider_if_exists,
            -- type = Figurine(1).  Will stand up
            type = 1
        }
    }
end

g_ignore_next_delete = {}

function onObjectDestroy(dying_object)
    local name = dying_object.getName()
    if g_ignore_next_delete[name] ~= nil then
        g_ignore_next_delete[name] = nil
        return
    end
    if is_table(dying_object) then
        print_info('Table removed from play')
        remove_deployment_lines()
        g_current_table = nil
        return
    end
    if is_base_obj(dying_object) then
      print_info('Base ' .. name .. ' removed from play')

      -- Do not remove the base from g_bases.  The object is marked
      -- as destroyed when it is put into a bag.  If the object is
      -- removed from the bag we need the bases settings.
      -- https://github.com/ArkeinGuardia/Triumph_TTS/issues/149

      set_last_snapshot()
      history_record_object_destroy(dying_object)
      remove_decorations_for_obj(dying_object)
    end
end


function delete_all_proxy()
    local all_objs = getAllObjects()
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'base Proxy') then
            -- This executes on next frame
            obj.destroy()
        end
    end
end

tile_proxy_15 = {
  height_correction = 0,
  scale = 1,
  rotation = 0,
  depth = 15,
  description = '15mm proxy tile',
  author = 'Plain tile by Marc.',
  mesh = { g_assets['dir'] .. 'troops/plain_tiles/tile_40_15.obj', },
  player_red_tex = g_assets['dir'] .. 'troops/icons/neutral_15.png',
  player_blue_tex = g_assets['dir'] .. 'troops/icons/neutral_15.png',
}

tile_proxy_20 = {
  height_correction = 0,
  scale = 1,
  rotation = 0,
  depth = 20,
  description = '20mm proxy tile',
  author = 'Plain tile by Marc.',
  mesh = { g_assets['dir'] .. 'troops/plain_tiles/tile_40_20.obj', },
  player_red_tex = g_assets['dir'] .. 'troops/icons/neutral_20.png',
  player_blue_tex = g_assets['dir'] .. 'troops/icons/neutral_20.png',
}

tile_proxy_30 = {
  height_correction = 0,
  scale = 1,
  rotation = 0,
  depth = 30,
  description = '30mm proxy tile',
  author = 'Plain tile by Marc.',
  mesh = { g_assets['dir'] .. 'troops/plain_tiles/tile_40_30.obj', },
  player_red_tex = g_assets['dir'] .. 'troops/icons/neutral_30.png',
  player_blue_tex = g_assets['dir'] .. 'troops/icons/neutral_30.png',
}

tile_proxy_40 = {
  height_correction = 0,
  scale = 1,
  rotation = 0,
  depth = 40,
  description = '40mm proxy tile',
  author = 'Plain tile by Marc.',
  mesh = { g_assets['dir'] .. 'troops/plain_tiles/tile_40_40.obj', },
  player_red_tex = g_assets['dir'] .. 'troops/icons/neutral_40.png',
  player_blue_tex = g_assets['dir'] .. 'troops/icons/neutral_40.png',
}

function spawn_proxy_after_deletion()
    spawn_base({
        name = 'Proxy 40x15',
        base = 'tile_proxy_15',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=-20}, 0, true)
    spawn_base({
        name = 'Proxy 40x20',
        base = 'tile_proxy_20',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=-21}, 0, true)
    spawn_base({
        name = 'Proxy 40x30',
        base = 'tile_proxy_30',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=-22.5}, 0, true)
    spawn_base({
        name = 'Proxy 40x40',
        base = 'tile_proxy_40',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=-24}, 0, true)


    spawn_base({
        name = 'Proxy 40x15',
        base = 'tile_proxy_15',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=20}, 180, false)
    spawn_base({
        name = 'Proxy 40x20',
        base = 'tile_proxy_20',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=21}, 180, false)
    spawn_base({
        name = 'Proxy 40x30',
        base = 'tile_proxy_30',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=22.5}, 180, false)
    spawn_base({
        name = 'Proxy 40x40',
        base = 'tile_proxy_40',
        ignore_terrain = 'false',
        n_models = 0,
        proxy = true
    }, {x=-42, y=2, z=24}, 180, false)
end

function spawn_proxy_bases()
    delete_all_proxy()
    Wait.frames(function()
        spawn_proxy_after_deletion()
    end, 1)
end
