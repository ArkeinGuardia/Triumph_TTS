-- Global number of MU to move
g_mu_movement = 3

-- Updates the global that manages the number of MUs moved by the other functions, and updates the UI
function slider_MUs_changed(player, value, id)
    g_mu_movement = round_to_decimals(value, 1)

    if math.abs(g_mu_movement - 1) < g_ui_snap_slider_movement then
        g_mu_movement = 1
    elseif math.abs(g_mu_movement - 2) < g_ui_snap_slider_movement then
        g_mu_movement = 2
    elseif math.abs(g_mu_movement - 3) < g_ui_snap_slider_movement then
        g_mu_movement = 3
    end

    -- It's undocumented, but changing the value of the button does not update
    -- the button_move_forward
    -- Instead we have to change the undocumented text attribute, but we still
    -- change the value because it's the proper thing
    UI.setAttribute('button_move_forward', 'text', 'Move ' .. g_mu_movement .. ' MU')
    UI.setValue('button_move_forward', 'Move ' .. g_mu_movement .. ' MU')

    -- Make it consistent for all players
    Wait.frames(function()
        UI.setAttribute('slider_MUs', 'value', value)
    end, 1)

    -- Update any gizmo
    draw_all_gizmos()
end

function move_bases(player, value, id)
    local objs = filter_bases(player.getSelectedObjects())
    if tlen(objs) < 1 then
        print_warning(player.steam_name ..' is trying to move, but (s)he has no object selected, ignoring')
    return
    end

    history_record_snapshot()

    for _,obj in ipairs(objs) do
        local moved = move_base(obj, from_mu_to_in(g_mu_movement), true)

        print_info(player.steam_name .. ' is moving ' .. obj.getName() .. ' '
            .. from_in_to_mu(moved) .. ' MU forward')
    end

    -- Moving the bases shpuld imply update the gizmos
    draw_all_gizmos()
end

function align_bases(player, value, id)
    local objs = filter_bases(player.getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs < 2 then
        print_error(player.steam_name ..' is trying to align ' .. n_objs .. ' bases, which is not supported')
        return
    end
    table.sort(objs, function(l, r)
        return l.getPosition()['x'] < r.getPosition()['x']
    end)

    -- Moving will mean that some attributes like the corner change, but they
    -- won't update on the object until next frame. However we still have to
    -- take into account here to aligning all the pieces together
    local future_transform = {}
    future_transform[objs[1].getName()] = calculate_transform(objs[1])

    for i=2,n_objs do
        local pos = objs[i].getPosition()
        local corners = compute_corners_base(objs[i])
        local transform = get_closest_transform(corners["topleft"], future_transform)

        local distance_centers = distance_points_flat_sq(transform['position'], pos)
        if (distance_centers > g_max_distance_alignment) then
            print_error(player.steam_name .. ' is trying to align but the bases are too far apart, more than 3inch between centers!')
            return
        end

        future_transform[objs[i].getName()] = align_two_bases(
            objs[i],
            transform['position'],
            transform['corners'],
            transform['rotation'])
    end

    -- Moving the bases shpuld imply update the gizmos
    draw_all_gizmos()
end

function on_cancel_load_army(player, value, id)
    UI.setAttribute('panel_dba_troop_selection', 'active', false)
    UI.setAttribute('panel_dba_troop_selection_bg', 'active', false)
    UI.setAttribute('panel_dba_troop_selection', 'visibility', '')
    UI.setAttribute('panel_dba_troop_selection_bg', 'visibility', '')
    UI.setAttribute('button_create_army', 'interactable', true)
end

function on_load_army(player, value, id)
    spawn_army(army[g_army_id_selected], g_color_spawn_army_selected == 'Red', g_command_spawn_army_selected)

    UI.setAttribute('panel_dba_troop_selection', 'active', false)
    UI.setAttribute('panel_dba_troop_selection_bg', 'active', false)
    UI.setAttribute('panel_dba_troop_selection', 'visibility', '')
    UI.setAttribute('panel_dba_troop_selection_bg', 'visibility', '')
    UI.setAttribute('button_create_army', 'interactable', true)
end

function is_army_with_models(army)
  local result = (army ~= nil) and (army.data ~= nil) and (army.data.has_models == true)
  return result
end

-- Should the army be displayed for deployment?
-- Based on the army having enough models to match the users filter.
function is_army_filtered_in(army)
  if not g_filter_armies_models then
    return true
  end
   return is_army_with_models(army)
end




g_use_plain_bases = false

-- Indication that the preference to use use plain bases or models has been made.
function on_use_plain_bases(player, value, id)
    g_use_plain_bases = value == "True"
    UI.setAttribute('toggle_use_plain_bases', 'isOn', g_use_plain_bases)
end

function on_filter_models(player, value, id)
    g_filter_armies_models = value == "True"
    on_next_frame(function()
        update_deploy_army_dialog()
    end)
end

-- Update the dialog values for deploying an army based on
-- the global variables.
function update_deploy_army_dialog()
    on_next_frame(function()
        UI.setAttribute('toggle_filter_modes', 'isOn', g_filter_armies_models)
        on_next_frame(function()
            update_theme_menu()
            on_next_frame(function()
                update_armies_menu()
                on_next_frame(function()
                    update_years_menu()
                end)
            end)
        end)
    end)
end

function create_army_options_menu(player, value, id)
    local status = UI.getAttribute('panel_dba_troop_selection', 'active')
    if status == 'True' then
        -- Ignore, the user is clicking despite the menu already being there
        return
    end

    on_next_frame(function()
        UI.setAttribute('panel_dba_troop_selection_bg', 'active', true)
        UI.setAttribute('panel_dba_troop_selection_bg', 'visibility', player.color)
        UI.setAttribute('panel_dba_troop_selection', 'active', true)
        UI.setAttribute('panel_dba_troop_selection', 'visibility', player.color)
        UI.setAttribute('button_create_army', 'interactable', false)

        update_deploy_army_dialog()
    end)
end

-----------------------------------------------------------
-- BEGIN global variables to indicte which army to deploy.
-----------------------------------------------------------

-- Should only armies with models be displayed as an option for deployment.
-- Boolean
g_filter_armies_models = false

-- Name of the selected theme. e.g. "Cradle of Civilization"
g_theme_selected = nil

-- Meshwesh ID of the army that is selected.
-- Example: 5fb1b9f6e1af06001770a4aa
g_army_id_selected = nil

-- Year to show as selected in UI elements.
-- Example: "1 AD to 5 AD"
g_year_selected = nil


-- Identifier of the army that should be spawned.
-- May be the Meshwesh ID such as  "5fb1b9f6e1af06001770a4aa",
--  or and augmented name  such as "5fb1b9f3e1af06001770a2fc_1266_1362"
-- for a period specific army
g_army_id_to_deploy = nil


-----------------------------------------------------------
-- END global variables to indicte which aremy to deploy.
-----------------------------------------------------------



-- Should the theme be displayed
function is_theme_filtered_in(theme_name)
    local themes_armies = armies[theme_name]
    for army_name,army in pairs(themes_armies) do
        if is_army_filtered_in(army) then
            return true
        end
    end
    return false
end


-- Update the menu item for all the themes that match the filter criteria.
-- filtered on model availablity.
-- Updates g_theme_selected
function update_theme_menu()
    local selected = nil
    local selected_index = nil
    local options = {}
    local index = 0
    for theme, army_name in pairs(armies) do
        if is_theme_filtered_in(theme) then
            index = index + 1
            table.insert(options, theme)
            if g_theme_selected == theme then
              selected = theme
              selected_index = index
            end
        end
    end
    if selected == nil then
      selected = options[1]
      selected_index = 1
    end
    g_theme_selected = selected
    set_options_dropdown_by_id('dropdown_book', options, selected_index)
end


-- Update the UI element for selecting an army based on the current
-- theme.
-- Use g_theme_selected to filter the armies.
-- Updates g_army_id_selected
function update_armies_menu()
    local selected_army_id = nil
    local selected_index = nil
    -- Sort by army name alphabetically
    local options = {}
    local index = 0
    local armies_in_theme = armies[g_theme_selected]
    for army_name, army_table in pairsByKeys(armies_in_theme) do
        if is_army_filtered_in(army_table) then
            index = index + 1
            table.insert(options, army_name)
            if g_army_id_selected == army_table.data.id then
              selected_army_id = g_army_id_selected
              selected_index = index
            end
        end
    end
    assert(index > 0)
    if selected_army_id == nil then
      selected_index = 1
      local selected_army_name = options[1]
      local selected_army = armies[g_theme_selected][selected_army_name]
      selected_army_id = selected_army.data.id
    end
    g_army_id_selected = selected_army_id

    set_options_dropdown_by_id('dropdown_army', options, selected_index)
end


-- Update the years menu based on the selction.
-- The menu contents are filled based on the contents of the global variable
-- g_army_id_selected.
-- Sets the global variables g_army_to_deploy and g_year_selected
function update_years_menu()
    if g_army_id_selected == nil then
      print_error("g_army_id_selected is nil")
      return
    end
    local selected = nil
    local selected_index = nil
    local options = {}
    index = 0
    local dates_for_army = army_dates[g_army_id_selected]
    assert(nil ~= dates_for_army)

    -- skip the selected army?  If there are multiple time periods do 
    -- not include the all encompassing period.
    local skip = nil
    if tlen(dates_for_army) > 1 then
-- For development we will no longer skip any dates so we can see all the models
-- for all dates.    
--      skip = g_army_id_selected
    end
      
    for year,army_id in pairs(dates_for_army) do
        if skip ~= army_id then
          index = index + 1
          table.insert(options, year)
          if year == g_year_selected then
            selected = year
            selected_index = index
          end
        end
    end
    if selected == nil then
      selected = options[1]
      selected_index = 1
    end
    g_year_selected = selected
    set_options_dropdown_by_id('dropdown_year', options, selected_index)
    g_army_to_deploy = dates_for_army[g_year_selected]
end



function on_theme_selected(player, value, id)
    g_theme_selected = value
    on_next_frame(function()
        update_deploy_army_dialog()
    end)
end


function on_army_selected(player, value, id)
    local army = armies[g_theme_selected][value]
    assert(army ~= nil)
    assert(army.data ~= nil)
    assert(army.data.id ~= nil)
    g_army_id_selected = army.data.id
    assert(nil ~= g_army_id_selected)
    on_next_frame(function()
        update_deploy_army_dialog()
    end)
end


-- Display value in UI for the year that has been chossen to deploy.
function on_year_selected(player, value, id)
    g_year_selected = value
    update_deploy_army_dialog()
end

g_color_spawn_army_selected = 'Red'
function on_color_selected(player, value, id)
    g_color_spawn_army_selected = value
end

g_command_spawn_army_selected = 'None'
function on_command_selected(player, value, id)
    g_command_spawn_army_selected = value
end

function add_pip(player, value, id)
    if value == 'red' then
        local pips_red = tonumber(UI.getValue('text_pips_player_red'))
        if pips_red < 6 then
            pips_red = pips_red + 1
        end
        UI.setValue('text_pips_player_red', pips_red)
    else
        local pips_blue = tonumber(UI.getValue('text_pips_player_blue'))
        if pips_blue < 6 then
            pips_blue = pips_blue + 1
        end
        UI.setValue('text_pips_player_blue', pips_blue)
    end
end

function remove_pip(player, value, id)
    if value == 'red' then
        local pips_red = tonumber(UI.getValue('text_pips_player_red'))
        if pips_red > 0 then
            pips_red = pips_red - 1
        end
        UI.setValue('text_pips_player_red', pips_red)
    else
        local pips_blue = tonumber(UI.getValue('text_pips_player_blue'))
        if pips_blue > 0 then
            pips_blue = pips_blue - 1
        end
        UI.setValue('text_pips_player_blue', pips_blue)
    end
end

-- Global enabled or disabled ZOC
g_zoc_enabled = false
function on_toggle_zoc(player, value, id)
    g_zoc_enabled = value == "True"

    if g_zoc_enabled then
        UI.setValue('toggle_zoc', 'Show ZOC')
        UI.setAttribute('toggle_zoc', 'text', 'Show ZOC')
    else
        UI.setValue('toggle_zoc', 'Do not show ZOC')
        UI.setAttribute('toggle_zoc', 'text', 'Do not show ZOC')
    end

    -- Make it consistent for all players
    on_next_frame(function()
        UI.setAttribute('toggle_zoc', 'isOn', g_zoc_enabled)
    end)
end

-- Global enabled or disabled deployment lines
g_deployment_lines_enabled = false
function on_toggle_deployment_lines(player, value, id)
    g_deployment_lines_enabled = value == "True"

    if g_deployment_lines_enabled then
        UI.setValue('toggle_deployment_lines', 'Show deployment rulers')
        UI.setAttribute('toggle_deployment_lines', 'text', 'Show deployment rulers')

        if g_current_table == nil then
            print_error('There\'s no table so deployment lines will have no effect. Please reenable when you spawned the table.')
        else
            draw_deployment_lines()
        end
    else
        UI.setValue('toggle_deployment_lines', 'Do not show rulers')
        UI.setAttribute('toggle_deployment_lines', 'text', 'Do not show rulers')

        if g_current_table ~= nil then
            remove_deployment_lines()
        end
    end

    -- Make it consistent for all players
    on_next_frame(function()
        UI.setAttribute('toggle_deployment_lines', 'isOn', g_deployment_lines_enabled)
    end)
end

function on_create_table_menu(player, value, id)
    g_use_3d_terrain = true
    g_is_double_dba = false
    UI.setAttribute('panel_dba_table_selection_bg', 'active', true)
    UI.setAttribute('panel_dba_table_selection_bg', 'visibility', player.color)
    UI.setAttribute('panel_dba_table_selection', 'active', true)
    UI.setAttribute('panel_dba_table_selection', 'visibility', player.color)
    UI.setAttribute('button_spawn_table', 'interactable', false)
    UI.setAttribute('button_create_army', 'interactable', false)
end

g_current_table_size = 'large'
function on_toggle_table_size(player, value, id)
    if value == "0" then
        g_current_table_size = 'small'
    else
        g_current_table_size = 'large'
    end
end

g_is_double_dba = false
function on_toggle_table_double(player, value, id)
    if value == "True" then
        g_is_double_dba = true
    else
        g_is_double_dba = false
    end
end

g_use_3d_terrain = true
function on_toggle_3dterrain(player, value, id)
    if value == "True" then
        g_use_3d_terrain = true
    else
        g_use_3d_terrain = false
    end
end

g_current_table_type = 0
function on_toggle_table_type(player, value, id)
    g_current_table_type = tonumber(value)
end

function from_toggle_number_to_table_type(value)
    -- Must follow the order of the toggles on main.xml
    if value == 0 then
        return 'grass'
    elseif value == 1 then
        return 'forest'
    elseif value == 2 then
        return 'tropical'
    elseif value == 3 then
        return 'mountain'
    elseif value == 4 then
        return 'desert'
    elseif value == 5 then
        return 'steppe'
    elseif value == 6 then
        return 'delta'
    elseif value == 7 then
        return 'marsh'
    else
        return 'Error'
    end
end

function on_load_table(player, value, id)
    local type = from_toggle_number_to_table_type(g_current_table_type)

    if tables[type] == nil then
        type = 'grass'
    end
    local tex = tables[type]['table_tex']

    local is_large = g_current_table_size == 'large'

    if g_current_table == nil then
        if g_is_double_dba then
            spawn_table_obj(tables['model_double'], tex, is_large)
        else
            spawn_table_obj(tables['model'], tex, is_large)
        end
        change_bases_to_terrain(type)
    else
        print_warning('There\'s already a table spawned')
    end

    UI.setAttribute('panel_dba_table_selection_bg', 'active', false)
    UI.setAttribute('panel_dba_table_selection_bg', 'visibility', '')
    UI.setAttribute('panel_dba_table_selection', 'active', false)
    UI.setAttribute('panel_dba_table_selection', 'visibility', '')
    UI.setAttribute('button_spawn_table', 'interactable', true)
    UI.setAttribute('button_create_army', 'interactable', true)
end

function on_cancel_load_table(player, value, id)
    UI.setAttribute('panel_dba_table_selection_bg', 'active', false)
    UI.setAttribute('panel_dba_table_selection_bg', 'visibility', '')
    UI.setAttribute('panel_dba_table_selection', 'active', false)
    UI.setAttribute('panel_dba_table_selection', 'visibility', '')
    UI.setAttribute('button_spawn_table', 'interactable', true)
    UI.setAttribute('button_create_army', 'interactable', true)
end

function on_push_back(player, value, id)
    local objs = filter_bases(player.getSelectedObjects())
    local len = tlen(objs)
    if len < 1 then
        print_warning(player.steam_name .. ' is pushing back troops but doesn\'t have any base selected')
        return
    end

    if len == 1 then
        local obj = table.remove(objs, 1)
        push_back(obj)
        draw_all_gizmos()
        return
    end

    push_back_column(objs)
    draw_all_gizmos()
end

g_player_wheeling = nil
function on_wheel(player, value, id)
    local objs = filter_bases(player.getSelectedObjects())
    local len = tlen(objs)
    if len < 1 then
        print_warning(player.steam_name .. ' is wheeling troops but doesn\'t have any base selected')
        return
    end

    on_rotation_wheel_ui(15)
    on_change_orientation_wheel_ui('left')
    local distance = preview_wheel(objs)
    if distance < 0 then
        print_warning(player.steam_name .. ' is wheeling troops but doesn\'t have a valid group selected')
        return
    end
    g_player_wheeling = player.color

    UI.setAttribute('panel_wheel_bg', 'active', true)
    UI.setAttribute('panel_wheel', 'active', true)
    UI.setAttribute('button_move_forward', 'interactable', false)
    UI.setAttribute('button_wheel', 'interactable', false)
    UI.setAttribute('button_push_back', 'interactable', false)
end

function preview_wheel(objs_if_first_time)
    local distance = wheel_group(objs_if_first_time,
        math.rad(g_degrees_wheeling), g_current_orientation)

    if distance < 0 then
        return distance
    end

    local mu = inches_to_mu_display_string(distance)
    UI.setValue('text_wheeling',
        string.format('Wheeling %2.1f degrees will cost %s',
            g_degrees_wheeling,
            mu))
    return distance
end

function on_make_wheeling(player, value, id)
    perform_wheels()
    g_current_wheel_group = nil
    g_current_wheel_transforms = nil
    g_current_wheel_newtransforms = nil
    g_player_wheeling = nil

    UI.setAttribute('panel_wheel_bg', 'active', false)
    UI.setAttribute('panel_wheel', 'active', false)
    UI.setAttribute('button_move_forward', 'interactable', true)
    UI.setAttribute('button_wheel', 'interactable', true)
    UI.setAttribute('button_push_back', 'interactable', true)

    Global.setVectorLines({})
end

function on_cancel_wheeling(player, value, id)
    g_current_wheel_group = nil
    g_current_wheel_transforms = nil
    g_current_wheel_newtransforms = nil
    g_player_wheeling = nil

    UI.setAttribute('panel_wheel_bg', 'active', false)
    UI.setAttribute('panel_wheel', 'active', false)
    UI.setAttribute('button_move_forward', 'interactable', true)
    UI.setAttribute('button_wheel', 'interactable', true)
    UI.setAttribute('button_push_back', 'interactable', true)

    Global.setVectorLines({})
end

g_degrees_wheeling = 0
function on_rotation_wheel(player, value, id)
    on_rotation_wheel_ui(value)
    preview_wheel(nil)
end

function on_rotation_wheel_ui(value)
    g_degrees_wheeling = value
    Wait.frames(function()
        UI.setAttribute('slider_wheel_rotation', 'value', value)
    end, 1)
end

g_current_orientation = 'left'
function on_change_orientation_wheel(player, value, id, ignore_preview)
    on_change_orientation_wheel_ui(from_toggle_number_to_orientation(tonumber(value)))
    preview_wheel(nil)

end

function on_change_orientation_wheel_ui(value)
    g_current_orientation = value
    if value == 'left' then
        Wait.frames(function()
            UI.setAttribute('toggle_wheel_left', 'isOn', true)
        end, 1)
    else
        Wait.frames(function()
            UI.setAttribute('toggle_wheel_right', 'isOn', true)
        end, 1)
    end
end


function from_toggle_number_to_orientation(value)
    -- Must follow the order of the toggles on main.xml
    if value == 0 then
        return 'left'
    elseif value == 1 then
        return 'right'
    else
        return 'Error'
    end
end

-- Global enabled snapping
g_snap_mode_enabled = true
function on_toggle_snapping(player, value, id)
    g_snap_mode_enabled = value == "True"

    if g_snap_mode_enabled then
        UI.setValue('toggle_snapping', 'Snap bases')
        UI.setAttribute('toggle_snapping', 'text', 'Snap bases')
    else
        UI.setValue('toggle_snapping', 'Do not snap bases')
        UI.setAttribute('toggle_snapping', 'text', 'Do not snap bases')
    end

    -- Make it consistent for all players
    on_next_frame(function()
        UI.setAttribute('toggle_snapping', 'isOn', g_snap_mode_enabled)
    end)
end

function update_pip(dice_obj_guid, id_text)
    local val = math.random(1,6)
    UI.setValue(id_text, val)
    getObjectFromGUID(dice_obj_guid).setValue(val)

    return val
end

-- This exists to avoid players clicking super fast and confusing rivals
g_roll_lock = {}

function on_roll_pips_red(player, value, id)
    if g_roll_lock['red'] then
        print_debug('Ignoring roll because this dice was rolled less than a second ago')
    else
        create_history_event_snapshot()
        g_roll_lock['red'] = true
        local red = roll_dice('red')
        if red == nil then return end
        local orange = roll_dice('orange')
        if orange == nil then return end
        local yellow = roll_dice('yellow')
        if yellow == nil then return end

        print_important('Red: ' .. red .. ' (Or: ' .. orange .. ' Yw: ' .. yellow .. ')')
        Wait.time(function ()
            g_roll_lock['red'] = false
        end, 0.5)
    end
end

function on_roll_pips_blue(player, value, id)
    if g_roll_lock['blue'] then
        print_debug('Ignoring roll because this dice was rolled less than a second ago')
    else
        create_history_event_snapshot()
        g_roll_lock['blue'] = true
        local blue = roll_dice('blue')
        local green = roll_dice('green')
        local purple = roll_dice('purple')

        print_important('Blue: ' .. blue .. ' (Gr: ' .. green .. ' Pr: ' .. purple .. ')')
        Wait.time(function ()
            g_roll_lock['blue'] = false
        end, 0.5)
    end
end

function on_undo_move(player, value, id)
    go_back_history_stack()
end

function on_redo_move(player, value, id)
    go_forward_history_stack()
end
