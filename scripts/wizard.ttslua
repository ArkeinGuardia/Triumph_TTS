
terrain_manditory = {}
terrain_manditory['steepe']={{type="Gentle hills"}}
terrain_manditory['dry']={{type="Rough"}}
terrain_manditory['forest']={{type="Woods"}}
terrain_manditory['marsh']={{type="Marsh"}}
terrain_manditory['arable']={{type="Village"}}
terrain_manditory['hilly']={{type="Steep hills"}}
terrain_manditory['delta']={{type="Coast"}}
terrain_optional = {}
terrain_optional['steepe']={
  {type="Stream"},
  {type="Rough"},
  {type="Woods", max=1},
  {type={"Gentle hills"}}
}
terrain_optional['dry']={
  {type="Dunes"},
  {type="Steep Hills"},
  {type="Oasis"},
  {type="Rough"}
}
terrain_optional['forest']={
  {type="Stream"},
  {type="Marsh"},
  {type="Wooded Hills"},
  {type="Woods"}
}
terrain_optional['marsh']={
  {type="Woods"},
  {type="Stream"},
  {type="Coast"},
  {type="Marsh"}
}
terrain_optional['arable']={
  {type="Stream"},
  {type="Steep Hills"},
  {type="Gentle Hills", max=1},
  {type="Woods"},
  {type="Wooded Hills"},
  {type="Coast"},
  {type="Rough"},
  {type="Ploughed Fields"}
}
terrain_optional['hilly']={
  {type="Stream"},
  {type="Woods"},
  {type="Wooded Hills"},
  {type="Steep Hills"}
}
terrain_optional['delta']={
  {type="Marsh"},
  {type="Dunes"},
  {type="Village"}
}

local terrain_bag_names = {
  "Dunes Ordinary Small",
  "Woods Ordinary Small",
  "Steep Hills Ordinary Small",
  "Gentle Hills Ordinary Small",
  "Wooded Hills Ordinary Small",
  "Rough Ordinary Small",
  "Marshes Ordinary Small",
  "Oasis Ordinary Small",
  "Villages Ordinary Small",
  "Ploughed Fields Ordinary Small",

  "Dunes Ordinary Large",
  "Woods Ordinary Large",
  "Steep Hills Ordinary Large",
  "Gentle Hills Ordinary Large",
  "Wooded Hills Ordinary Large",
  "Rough Ordinary Large",
  "Marshes Ordinary Large",
  "Oasis Ordinary Large",
  "Villages Ordinary Large",
  "Ploughed Fields Ordinary Large",

  "Dunes Edge Small",
  "Woods Edge Small",
  "Steep Hills Edge Small",
  "Gentle Hills Edge Small",
  "Wooded Hills Edge Small",
  "Rough Edge Small",
  "Marshes Edge Small",
  "Oasis Edge Small",
  "Villages Edge Small",
  "Ploughed Fields Edge Small",

  "Dunes Edge Large",
  "Woods Edge Large",
  "Steep Hills Edge Large",
  "Gentle Hills Edge Large",
  "Wooded Hills Edge Large",
  "Rough Edge Large",
  "Marshes Edge Large",
  "Oasis Edge Large",
  "Villages Edge Large",
  "Ploughed Fields Edge Large",

  "Coasts",
  "Streams"
}

-- used: Set of names of the terrain that can be placed on the table_type.
--  e.g. "Woods"
-- bag_name: Name of a bag to check. e.g. "Gentle Hills Ordinary Small"
function is_terrain_bag_used(used, bag_name)
  for terrain,_ in pairs(used) do
    if  str_starts_with(bag_name, terrain) then
      return true
    end
  end
  return false
end

function destroy_unused_terrain_bags()
  local topography = g_game_settings['topography']
  -- build up the used terrain
  local used = {}
  for _,terrain in pairs(terrain_manditory[topography]) do
    local type = terrain['type']
    used[type] = true
  end
  for _,terrain in pairs(terrain_optional[topography]) do
    local type = terrain['type']
    used[type] = true
  end
  for _,bag_name in pairs(terrain_bag_names) do
    local bag = get_object_by_name(bag_name)
    if nil == bag then
      print_warning("Unable to find terrain bag " .. bag_name)
    else
      if not is_terrain_bag_used(used, bag_name) then
        bag.destruct()
      end
    end
  end
end

function destroy_all_terrain_bags()
  for _,bag_name in pairs(terrain_bag_names) do
    local bag = get_object_by_name(bag_name)
    if nil ~= bag then
      bag.destruct()
    end
  end
end


g_wizard_exit_panel_fn = nil




wizard_panels = {
  "wizard_panel_game",
  "wizard_panel_select_armies",
  "wizard_panel_select_troops",
   "wizard_panel_invader",
   "wizard_panel_topography",
   "wizard_panel_tactical_advantage",
   "wizard_panel_terrain_pieces_roll",
   "wizard_panel_terrain_score",
   "wizard_panel_terrain_selection",
   "wizard_panel_terrain_placement",
   "wizard_panel_camps",
   "wizard_panel_deploy_troops",
   "wizard_panel_first_move",
}

function get_tactical_disadvantage()
  local advantage = g_game_settings['tactical_advantage']
  if advantage == nil then
    print_error("tactical_advantage has not been set")
    return "red"
  end
  if advantage == "red" then
    return "blue"
  else
    return "red"
  end
end


function wizard_show_panel(panel_name)
  if g_wizard_exit_panel_fn then
    g_wizard_exit_panel_fn()
    g_wizard_exit_panel_fn = nil
  end
  local wizard_active = false
  for _,name in pairs(wizard_panels) do
    local panel_active = (name == panel_name)
    UI.setAttribute(name, "active", panel_active)
    wizard_active = wizard_active or panel_active
  end
  UI.setAttribute("panel_wizard_bg", "active", wizard_active)
  g_game_settings['wizard_page'] = panel_name
end

function wizard_hide()
  wizard_show_panel("none")
  update_current_ui()
end

function is_wizard_showing()
  if not g_game_settings['wizard_page'] then
    return false
  end
  if g_game_settings['wizard_page'] == "none" then
    return false
  end
  return true
end


-------------------
------------------- Game Panel
-------------------

function wizard_show_panel_game()
  wizard_show_panel("wizard_panel_game")
  wizard_panel_game_enter()
end

function wizard_pannel_game_update()
  local is_grand_triumph = g_game_settings['is_grand_triumph']
  if is_grand_triumph == nil then
    UI.setAttribute("wizard_togglegroup_game_triumph", "isOn", false)
    UI.setAttribute("wizard_togglegroup_game_grand_triumph", "isOn", false)
    return
  end

  UI.setAttribute("wizard_togglegroup_game_triumph", "isOn", not is_grand_triumph)
  UI.setAttribute("wizard_togglegroup_game_grand_triumph", "isOn", is_grand_triumph)

  local next_enabled = (g_game_settings['is_grand_triumph'] ~= nil)
  UI.setAttribute("wizard_panel_game_next", "interactable", next_enabled)
end

function wizard_panel_game_enter()
  wizard_pannel_game_update()
  g_wizard_exit_panel_fn = function()
    spawn_all_dice()
  end
end

function on_wizard_togglegroup_game(player, value, id)
  g_game_settings['is_grand_triumph'] = (value == "1")
  wizard_pannel_game_update()
end

function on_wizard_button_forward_to_select_armies()
      wizard_show_panel_select_armies()
end

-------------------
------------------- Select armies
-------------------


function on_wizard_panel_select_armies_previous()
  wizard_show_panel_game()
end

function on_wizard_panel_select_armies_next()
  wizard_show_panel_select_troops()
end

function wizard_panel_select_armies_update()
  local enable_next = (g_game_settings['army_id'] ~= nil) and (g_game_settings['army_id'] ['red'] ~= nil) and (g_game_settings['army_id'] ['blue'] ~= nil)
  UI.setAttribute("wizard_panel_select_armies_next", "interactable", enable_next)
end

function wizard_show_panel_select_armies()
  wizard_show_panel("wizard_panel_select_armies")
  g_load_army_callback = wizard_panel_select_armies_update
  g_wizard_exit_panel_fn = function()
    g_load_army_callback = nil
  end
  wizard_panel_select_armies_update()
end


-------------------
------------------- Select troops
-------------------

function wizard_show_panel_select_troops()
  wizard_show_panel("wizard_panel_select_troops")
  g_wizard_exit_panel_fn = function()
    -- make the bases visible to everyone
    for _, base in pairs(get_all_bases()) do
      base.setInvisibleTo({})
    end
    g_movement_reporting_enabled = true
    g_gizmo_drawing_disabled = false
  end

  -- make the bases invisible to the other player
  g_movement_reporting_enabled = false
  g_gizmo_drawing_disabled = true
  for _, base in pairs(get_all_bases()) do
    if is_base_blue_player(base) then
      base.setInvisibleTo({"Red"})
    else
      base.setInvisibleTo({"Blue"})
    end
  end

  g_game_settings['use_army_builder'] = true
end


function on_wizard_panel_select_troops_previous()
  wizard_show_panel_select_armies()
end


function on_wizard_panel_select_troops_next()
  wizard_show_panel_invader()
end

-------------------
------------------- Invader
-------------------

function wizard_show_panel_invader()
  wizard_show_panel("wizard_panel_invader")
  g_wizard_exit_panel_fn = wizard_panel_exit_invader
  wizard_panel_invader_set_ratings()
  g_dice_callbacks['invasion_dice_rolled'] = on_invasion_dice_rolled
  update_invasion_wizard_page()
end


function wizard_panel_exit_invader()
  g_dice_callbacks["invasion_dice_rolled"] = nil
end

-- Disable the invasion ratings that do not apply to an army.
-- color: Player color for the army
function wizard_panel_invader_set_ratings_for_color(color)
  local army_id = g_game_settings['army_id'] [color]
  local army = army[army_id]
  local data = army['data']
  local invasionRatings = data['invasionRatings']
  for i=0,5,1 do
    local id = "wizard_togglegroup_invasion_" .. color .. "_" .. tostring(i)
    UI.setAttribute(id, "active", "false")
  end
  for _,value in ipairs(invasionRatings) do
    local id = "wizard_togglegroup_invasion_" .. color .. "_" .. tostring(value)
    UI.setAttribute(id, "active", "true")
  end
end

-- Disable the invastion ratings that do not apply for the armies selected.
function wizard_panel_invader_set_ratings()
  wizard_panel_invader_set_ratings_for_color('red')
  wizard_panel_invader_set_ratings_for_color('blue')
end

function on_invasion_dice_rolled(dice_color, value)
  if g_game_settings['invader'] == nil then
    local id = "text_" .. dice_color .. "_invasion_roll_value"
    UI.setAttribute(id, "text", tostring(value))
    update_invasion_wizard_page()
  end
end

function on_button_red_invasion_roll()
  roll_dice('red')
end

function on_button_blue_invasion_roll()
  roll_dice('blue')
end

function on_red_invasion_rating_selected(player, value, id)
  local rating = tonumber(value)
  g_game_settings['invasion_rating']['red'] = rating
  update_invasion_wizard_page()
end

function on_blue_invasion_rating_selected(player, value, id)
  local rating = tonumber(value)
  g_game_settings['invasion_rating']['blue'] = rating
  update_invasion_wizard_page()
end

-- Update the score box for the invasion wizard
-- color: "red" or "blue"
-- return: total or nil if the value is not yet ready
function update_invasion_wizard_score(color)
  local score_id = color .. "_invasion_score"
  local dice_id = "text_" .. color .. "_invasion_roll_value"
  local dice_str = UI.getAttribute(dice_id, "text")
  local dice = tonumber(dice_str)
  if dice == nil then
    UI.setAttribute(score_id, "text", "")
    return nil
  end
  if g_game_settings['invasion_rating'][color] == nil then
    return nil
  end

   local rating = g_game_settings['invasion_rating'][color]
   if rating == nil then
     UI.setAttribute(score_id, "text", "")
     return nil
   end

   local score = dice + rating
   UI.setAttribute(score_id, "text", tostring(score))
   return score
end

function do_update_invasion_wizard_page()
  if g_game_settings['invader'] ~= nil then
    g_dice_callbacks['invasion_dice_rolled'] = nil

    UI.setAttribute("red_invasion_rating", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_0", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_1", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_2", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_3", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_4", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_5", "interactable", false)
    UI.setAttribute("button_red_invasion_roll", "interactable", false)

    UI.setAttribute("blue_invasion_rating", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_0", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_1", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_2", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_3", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_4", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_5", "interactable", false)
    UI.setAttribute("button_blue_invasion_roll", "interactable", false)

    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_invader_next", "interactable", true)
      end,
      1)

    return
  end

  local red_score = update_invasion_wizard_score("red")
  local blue_score = update_invasion_wizard_score("blue")
  if red_score == nil or blue_score == nil then
    UI.setAttribute("invader", "text", "")
    UI.setAttribute("wizard_panel_invader_next", "interactable", false)
    return
  end
  if red_score == blue_score then
    UI.setAttribute("invader", "text", "tie, roll again")
    UI.setAttribute("text_blue_invasion_roll_value", "text", "")
    UI.setAttribute("text_red_invasion_roll_value", "text", "")
    UI.setAttribute("wizard_panel_invader_next", "interactable", false)
    g_game_settings['invader']=nil
    return
  end
  if red_score > blue_score then
    UI.setAttribute("invader", "text", "Red invades")
    g_game_settings['invader'] = "red"
    print_info("Red invades")
    g_game_settings['invader']="red"
  else
    UI.setAttribute("invader", "text", "Blue invades")
    g_game_settings['invader'] = "blue"
    print_info("Blue invades")
    g_game_settings['invader']="blue"
  end
  do_update_invasion_wizard_page()

  Wait.frames(
    function()
      UI.setAttribute("wizard_panel_invader_next", "interactable", true)
    end,
    1)

end


function update_invasion_wizard_page()
  -- Need to wait one frame for the UI elements to update
  -- before we can query them
  Wait.frames(
    function()
      do_update_invasion_wizard_page()
    end,
    1)
end

function on_wizard_panel_invader_next()
  wizard_show_panel_topography()
end

function on_wizard_panel_invader_previous()
  wizard_show_panel_select_troops()
end

-------------------
------------------- Topography
-------------------

g_topographies = {'arable', 'forest', 'hilly', 'dry', 'steepe', 'marsh', 'delta'}

function wizard_show_panel_topography()
  -- set the table type before populating otherwise it will be set to zero.
  local defender
  if g_game_settings['invader']=='blue' then
    defender = 'red'
  else
    defender = 'blue'
  end
  local army_id = g_game_settings['army_id'] [defender]
  local army = army[army_id]
  local data = army['data']
  local homeTopographies =  data['homeTopographies']
  for table_type,topo in ipairs(g_topographies) do
    local active =  find_in_array(homeTopographies, topo, str_equals_case_insensitive)
    if active then
      g_game_settings["table type"] = table_type
    end
  end

  wizard_show_panel("wizard_panel_topography")
  UI.setAttribute("wizard_topgraphy_defender", "text", defender)
  for table_type,topo in ipairs(g_topographies) do
      local active =  find_in_array(homeTopographies, topo, str_equals_case_insensitive)
      local id = "wizard_topography_" .. topo
      UI.setAttribute(id, "active", tostring(active))
  end
  wizard_panel_topography_update()
  g_wizard_exit_panel_fn = wizard_panel_topography_exit

end

function on_wizard_topography_selected(player, value, id)
  g_game_settings["table type"] = tonumber(value)
  g_game_settings['topography'] = g_topographies[g_game_settings["table type"]+1]
  wizard_panel_topography_update()
end

function on_wizard_panel_topography_spawn_table()
  if g_game_settings['topography'] == nil then
    return
  end
  load_table(g_game_settings["table type"])

  Wait.frames(
    function()
      g_game_settings['table_spawned'] = true
      destroy_unused_terrain_bags()
      wizard_panel_topography_update()
    end,
    1)
end

function wizard_panel_topography_update()
  if nil ~= g_game_settings["topography"] then
    -- select the topography that has been previously chosen
    local selected_id = "wizard_topography_" .. g_game_settings["topography"]
    for _,topo in ipairs(g_topographies) do
      local id = "wizard_topography_" .. topo
      if selected_id == id then
        UI.setAttribute(id, "isOn", true)
      else
        UI.setAttribute(id, "isOn", false)
      end
    end
  end
  if (nil ~= g_game_settings['table_spawned'])  and (nil ~= g_game_settings['topography']) then
    UI.setAttribute("wizard_topography_arable", "interactable", false)
    UI.setAttribute("wizard_topography_forest", "interactable", false)
    UI.setAttribute("wizard_topography_hilly", "interactable", false)
    UI.setAttribute("wizard_topography_dry", "interactable", false)
    UI.setAttribute("wizard_topography_steepe", "interactable", false)
    UI.setAttribute("wizard_topography_delta", "interactable", false)
    UI.setAttribute("wizard_topography_marsh", "interactable", false)
    UI.setAttribute("wizard_panel_topography_spawn_table", "interactable", false)

    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_topography_next", "interactable", true)
      end,
      1)
      return
  end

  if (nil == g_game_settings['topography']) then
    UI.setAttribute("wizard_panel_topography_spawn_table", "interactable", false)
  else
    UI.setAttribute("wizard_panel_topography_spawn_table", "interactable", true)
  end

end

function on_wizard_panel_topography_previous()
  wizard_show_panel_invader()
end

function on_wizard_panel_topography_next()
  wizard_show_panel_tactical_advantage()
end

function wizard_panel_topography_exit()
  g_load_table_callback = nil
end

-------------------
------------------- Tatucal Advantage
-------------------

function wizard_show_panel_tactical_advantage()
  wizard_show_panel("wizard_panel_tactical_advantage")
  wizard_panel_tactical_advantage_update_manueuver_ratings()
  g_dice_callbacks['tactical_advantage_dice_rolled'] = on_tactical_advantage_dice_rolled
  g_wizard_exit_panel_fn = wizard_panel_exit_tactical_advantage
  do_update_tactical_advantage_wizard_page()
end

function wizard_panel_exit_tactical_advantage()
  g_dice_callbacks["tactical_advantage_dice_rolled"] = nil
end

function on_wizard_panel_tactical_advantage_previous()
  wizard_show_panel_topography()
end

function on_wizard_panel_tactical_advantage_next()
  wizard_show_panel_terrain_pieces_roll()
end

function on_tactical_advantage_dice_rolled(dice_color, value)
  if nil == g_game_settings["tactical_advantage_score"] then
    local id = "wizard_maneuver_roll_value_" .. dice_color
    UI.setAttribute(id, "text", tostring(value))
    g_game_settings[id] = value
    wizard_panel_tactical_advantage_update()
  end
end

function on_wizard_red_maneuver_rating_selected(player, value, id)
  print_info("Red maneuver rating " .. tostring(value))
  local maneuverRatings =  get_maneuver_ratings_for_color('red')
  local rating = maneuverRatings[value]
  g_game_settings['wizard_maneuver_rating_red'] = rating
  set_maneuver_rating_selected(id, rating)
  wizard_panel_tactical_advantage_update()
end

function on_wizard_blue_maneuver_rating_selected(player, value, id)
  print_info("Blue maneuver rating " .. tostring(value))
  local maneuverRatings =  get_maneuver_ratings_for_color('blue')
  local rating = maneuverRatings[value]
  g_game_settings['wizard_maneuver_rating_blue'] = rating
  set_maneuver_rating_selected(id, rating)
  wizard_panel_tactical_advantage_update()
end

function on_wizard_button_red_maneuver_roll()
  roll_dice('red')
end

function on_wizard_button_blue_maneuver_roll()
  roll_dice('blue')
end

-- color: either "blue" or "red"
function get_maneuver_ratings_for_color(color)
  local army_id = g_game_settings['army_id'] [color]
  local army = army[army_id]
  local data = army['data']
  local maneuverRatings =  data['maneuverRatings']
  return maneuverRatings
end

-- xml: XML table to modify
-- color:  Color of the player whose maneuver rating we are updating
-- either 'blue' or 'red'
function wizard_tactical_advantage_update_maneuver_rating(xml, color)
  local maneuverRatings =  get_maneuver_ratings_for_color(color)
  local menu_id = "wizard_maneuver_rating_" .. color
  local options = {}
  local selected_index = nil
  for index,maneuverRating in ipairs(maneuverRatings) do
    table.insert(options, tostring(maneuverRating))
    if g_game_settings[menu_id] == maneuverRating then
      selected_index = index
    end
  end
  if selected_idex == nil then
    selected_index = 1
    g_game_settings[menu_id] = maneuverRatings[selected_index]
  end
  set_options_dropdown_by_id_xml(xml, menu_id, options, selected_index)
end


function wizard_panel_tactical_advantage_update_manueuver_ratings()
  local xml = UI.getXmlTable()
  wizard_tactical_advantage_update_maneuver_rating(xml, "red")
  wizard_tactical_advantage_update_maneuver_rating(xml, "blue")
  UI.setXmlTable(xml)
end

function wizard_update_flank_march_for_color(color)
  local flank_id = color .. "_flank_march"
  if g_game_settings[flank_id] ~= nil then
    return
  end
  local rating_id = "wizard_maneuver_rating_" .. color
  local maneuver_rating = g_game_settings[rating_id]
  if maneuver_rating == nil then
    return
  end
  local dice_id = "wizard_maneuver_roll_value_" .. color
  local dice = g_game_settings[dice_id]
  if dice == nil then
    return
  end
  local flank = ((dice == 1) or (dice < maneuver_rating))

  g_game_settings[flank_id] = flank
  local wizard_id = "wizard_" .. flank_id
  if flank then
    UI.setAttribute(wizard_id, "text", "Flank March")
    print_info(color .. " is eligible for flank march.")
    local face_URL
    local z_pos = 35.50
    local y_rotation = 0
    if color == "red" then
      face_URL="http://cloud-3.steamusercontent.com/ugc/1807610517240746012/48DD837201B66B45C44C45CB86585773540F54DF/"
      z_pos = -z_pos
      y_rotation = 180
    else
      face_URL="http://cloud-3.steamusercontent.com/ugc/1807610517240745877/939F09683E86259AB2F0D92A721F0C173651C78C/"
    end
    local flank_card_data =
     {
       Name= "CardCustom",
       Transform= {
         posX= 0,
         posY= 3.01,
         posZ= z_pos,
         rotX= 0,
         rotY= y_rotation,
         rotZ= 180.0,
         scaleX= 1.87838769,
         scaleY= 1.0,
         scaleZ= 1.87838769
       },
       ColorDiffuse= {
         r= 1.0,
         g= 0.0,
         b= 0.0
       },
     }
    local flank_card= spawnObjectData( { data=flank_card_data})
    flank_card.setCustomObject( {
       type=1,
       face=face_URL,
       back=face_URL } )
  else
    UI.setAttribute(wizard_id, "text", "")
    print_info("No flank march for " .. color)
  end
end

-- Update the score box for the tactical advanage  wizard
-- color: "red" or "blue"
-- return: total or nil if the value is not yet ready
function update_tactical_maneuver_wizard_score(color)
  local score_id = "wizard_" .. color .. "_maneuver_score"
  local rating_id = "wizard_maneuver_rating_" .. color
  local rating = g_game_settings[rating_id]
  if rating == nil then
    UI.setAttribute(score_id, "text", "")
    return nil
  end

  local dice_id = "wizard_maneuver_roll_value_" .. color
  local dice = g_game_settings[dice_id]
  if dice == nil then
    UI.setAttribute(score_id, "text", "")
    return nil
  end

  local score = dice + rating
  UI.setAttribute(score_id, "text", tostring(score))
  return score
end

function do_update_tactical_advantage_wizard_page()
  if g_game_settings["tactical_advantage_score"] ~= nil then
    UI.setAttribute("wizard_maneuver_rating_red", "interactable", false)
    UI.setAttribute("wizard_maneuver_rating_blue", "interactable", false)
    UI.setAttribute("wizard_button_red_maneuver_roll", "interactable", false)
    UI.setAttribute("wizard_button_blue_maneuver_roll", "interactable", false)
    g_dice_callbacks['tactical_advantage_dice_rolled'] = nil

    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_tactical_advantage_next", "interactable", true)
      end,
      1)

    return
  end

  local red_score = update_tactical_maneuver_wizard_score("red")
  local blue_score = update_tactical_maneuver_wizard_score("blue")
  wizard_update_flank_march_for_color('red')
  wizard_update_flank_march_for_color('blue')
  if red_score == nil or blue_score == nil then
    UI.setAttribute("wizard_text_tactical_advantage_player", "text", "")
    UI.setAttribute("wizard_text_tactical_advantage_score", "text", "")
    return
  end
  if red_score == blue_score then
    UI.setAttribute("wizard_text_tactical_advantage_player", "text", "tie, roll again")
    UI.setAttribute("wizard_maneuver_roll_value_red", "text", nil)
    UI.setAttribute("wizard_maneuver_roll_value_blue", "text", nil)
    return
  end
  local advantage = math.abs(red_score - blue_score)
  g_game_settings["tactical_advantage_score"] = advantage
  UI.setAttribute("wizard_text_tactical_advantage_score", "text", tostring(advantage))
  if red_score > blue_score then
      UI.setAttribute("wizard_text_tactical_advantage_player", "text", "Red tactical advantage: ")
      g_game_settings['tactical_advantage'] = "red"
  else
     UI.setAttribute("wizard_text_tactical_advantage_player", "text", "Blue tactical advantage: ")
     g_game_settings['tactical_advantage'] = "blue"
  end
  g_dice_callbacks['tactical_advantage_dice_rolled'] =  nil
  UI.setAttribute("wizard_panel_tactical_advantage_next", "interactable", true)
  print_important("tactical advantage " .. g_game_settings['tactical_advantage'] ..
    ' ' .. tostring(g_game_settings["tactical_advantage_score"]))
  do_update_tactical_advantage_wizard_page()
end

function wizard_panel_tactical_advantage_update()
  -- Need to wait one frame for the UI elements to update
  -- before we can query them
  Wait.frames(
    function()
      do_update_tactical_advantage_wizard_page()
    end,
    1)
end

-------------------
------------------- terrain pieces roll
-------------------

function wizard_show_panel_terrain_pieces_roll()
  wizard_show_panel("wizard_panel_terrain_pieces_roll")
  g_dice_callbacks['terrain_pieces_dice_rolled'] = on_terrain_pieces_dice_rolled
  g_wizard_exit_panel_fn = wizard_panel_exit_terrain_pieces_roll
  wizard_panel_terrain_pieces_roll_update()
end

function wizard_panel_exit_terrain_pieces_roll()
  g_dice_callbacks["terrain_pieces_dice_rolled"] = nil
end

function on_wizard_panel_terrain_pieces_roll_previous()
  wizard_show_panel_tactical_advantage()
end


function on_wizard_panel_terrain_pieces_roll_next()
  wizard_show_panel_terrain_score()
end

function on_wizard_button_red_terrain_pieces_roll()
  roll_dice('red')
end

function on_wizard_button_blue_terrain_pieces_roll()
  roll_dice('blue')
end

function on_terrain_pieces_dice_rolled(dice_color, value)
  if nil == g_game_settings['terrain_score_high'] then
    local id = "wizard_terrain_pieces_roll_value_" .. dice_color
    UI.setAttribute(id, "text", tostring(value))
    g_game_settings[id] = value
  end
  wizard_panel_terrain_pieces_roll_update()
end


function wizard_panel_terrain_pieces_roll_update()
  if nil ~= g_game_settings['terrain_score_high'] then
    g_dice_callbacks['terrain_pieces_dice_rolled'] = nil
    UI.setAttribute("wizard_button_red_terrain_pieces", "interactable", false)
    UI.setAttribute("wizard_button_blue_terrain_pieces", "interactable", false)
    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_terrain_pieces_roll_next", "interactable", true)
      end,
      1)
    return
  end

  UI.setAttribute("wizard_panel_terrain_pieces_roll_tactical_advantage", "text",
    tostring(g_game_settings["tactical_advantage_score"]))
  if g_game_settings["wizard_terrain_pieces_roll_value_blue"] == nil or
     g_game_settings["wizard_terrain_pieces_roll_value_red"] == nil
  then
    UI.setAttribute("wizard_panel_terrain_pieces_roll_total", "text", "")
    UI.setAttribute("wizard_panel_terrain_pieces_roll_terrain_score", "text", "")
    return
  end
  local total = g_game_settings["wizard_terrain_pieces_roll_value_blue"] +
      g_game_settings["wizard_terrain_pieces_roll_value_red"]
  UI.setAttribute("wizard_panel_terrain_pieces_roll_total", "text", tostring(total))

  local low = total - g_game_settings["tactical_advantage_score"]
  local high = total + g_game_settings["tactical_advantage_score"]
  if low < 2 then
    low = 2
  end
  if high > 12 then
    high = 12
  end
  local terrain_score = "Terrain Score: " .. tostring(low) .. " - " .. tostring(high)
  UI.setAttribute("wizard_panel_terrain_pieces_roll_terrain_score", "text", terrain_score)

  g_game_settings['terrain_score_low'] = low
  g_game_settings['terrain_score_high'] = high
  wizard_panel_terrain_pieces_roll_update()
end


-------------------
------------------- nb terrain pieces selection
-------------------
terrain_nb_pieces = {}
terrain_nb_pieces['steepe']={1,1,1,2,2,3,3,4,4,5,5}
terrain_nb_pieces['dry']=terrain_nb_pieces['steepe']
terrain_nb_pieces['forest']={2,3,3,4,4,5,5,6,6,6,6}
terrain_nb_pieces['marsh']=terrain_nb_pieces['forest']
terrain_nb_pieces['arable']={1,2,2,3,3,3,4,4,5,5,6,6}
terrain_nb_pieces['hilly']=terrain_nb_pieces['arable']
terrain_nb_pieces['delta']=terrain_nb_pieces['arable']
-- is a coast required.  index+1 = terrain score
terrain_coast = {false,false,true,false,false,true,false,false,true,false,false}

function wizard_show_panel_terrain_score()
  wizard_show_panel("wizard_panel_terrain_score")

  -- Enable and disable the toggles for the terain score
  for score=2,g_game_settings['terrain_score_low']-1 , 1 do
    local id = "wizard_terrain_score_" .. tostring(score)
    UI.setAttribute(id, "active", false)
  end
  for score=g_game_settings['terrain_score_low'] ,g_game_settings['terrain_score_high'] , 1 do
    local id = "wizard_terrain_score_" .. tostring(score)
    UI.setAttribute(id, "active", true)
  end
  for score=g_game_settings['terrain_score_high']+1 ,12, 1 do
    local id = "wizard_terrain_score_" .. tostring(score)
    UI.setAttribute(id, "active", false)
  end

   -- Update the number of pieces based on the topography
  local topography =  g_game_settings['topography']
  for score=2,12,1 do
    local id = "wizard_terrain_score_nb_pieces_" .. tostring(score)
    local value = terrain_nb_pieces[topography][score-1]
    UI.setAttribute(id, "text", tostring(value))
  end
  wizard_panel_terrain_score_update()
  g_wizard_exit_panel_fn = wizard_panel_exit_terrain_score
end

function on_wizard_panel_terrain_score_previous()
  wizard_show_panel_terrain_pieces_roll()
end


function on_wizard_panel_terrain_score_next()
  wizard_show_panel_terrain_selection()
end

function on_wizard_tarrain_score_selected(player, value, id)
  g_game_settings['terrain_score']  = tonumber(value) + 2
  local terrain_score = g_game_settings['terrain_score']
  g_game_settings['coast_allowed'] =  terrain_coast[terrain_score-1]
  wizard_panel_terrain_score_update()
end


function wizard_panel_exit_terrain_score()
  local terrain_score = g_game_settings['terrain_score']
  local topography =  g_game_settings['topography']
  local nb_pieces = terrain_nb_pieces[topography][terrain_score-1]
  local coast
  if g_game_settings['coast_allowed'] then
    coast = " coast"
  else
    coast = ""
  end
  print_important("terrain score: " .. tostring(terrain_score) .. " nb pieces: " .. tostring(nb_pieces) ..  coast)
end

function wizard_panel_terrain_score_update()
  if g_game_settings['terrain_score'] ~= nil then
    UI.setAttribute("wizard_panel_terrain_score_next", "interactable", true)
    local id = "wizard_terrain_score_" .. tostring(g_game_settings['terrain_score'])
    UI.setAttribute(id, "isOn", true)
  end
end


-------------------
------------------- Terrain Selection
-------------------


-- terrain_list: an entery from the terrain_optional table_type
-- return: string for human consumption
function format_terrain_list(terrain_list)
  local result = ""
  local first = true
  for _,terrain in pairs(terrain_list) do
    if not first then
      result = result .. ", "
    end
    first = false
    result = result .. terrain['type']
    if nil ~= terrain['max'] then
      result = result .. "(" .. tostring(terrain['max']) .. ")"
    end
  end
  return result
end


function on_wizard_panel_terrain_selection_previous()
  wizard_show_panel_terrain_score()
end


function on_wizard_panel_terrain_selection_next()
  wizard_show_panel_terrain_placement()
end


function wizard_show_panel_terrain_selection()
  local advantage = g_game_settings['tactical_advantage']
  local terrain_score = g_game_settings['terrain_score']
  local topography =  g_game_settings['topography']
  local nb_pieces = terrain_nb_pieces[topography][terrain_score-1]
  local nb_optional_pieces = nb_pieces - 1
  UI.setAttribute("wizard_terrain_selection_advantage", "text", advantage);
  UI.setAttribute("wizard_terrain_selection_topography", "text", topography);
  UI.setAttribute("wizard_terrain_selection_terrain_score", "text", tostring(terrain_score));
  local coast
  if g_game_settings['coast_allowed'] then
    coast = " coast allowed"
  else
    coast = ""
  end
  UI.setAttribute("wizard_terrain_selection_coast", "text", coast);
  UI.setAttribute("wizard_terrain_selection_manditory", "text",
    format_terrain_list(terrain_manditory[topography]));
  UI.setAttribute("wizard_terrain_selection_optional_nb_pieces", "text", tostring(nb_optional_pieces));
  if nb_optional_pieces <= 0 then
    UI.setAttribute("wizard_terrain_selection_optional", "text", "");
  else
    UI.setAttribute("wizard_terrain_selection_optional", "text",
      format_terrain_list( terrain_optional[topography]) );
  end
  wizard_show_panel("wizard_panel_terrain_selection")
end

-------------------
------------------- Terrain Placement
-------------------

function on_wizard_panel_terrain_placement_previous()
  wizard_show_panel_terrain_selection()
end


function on_wizard_panel_terrain_placement_next()
  wizard_show_panel_camps()
end


function wizard_panel_exit_terrain_placement()
  remove_deployment_lines()
  g_game_table_callbacks['wizard_panel_terrain_placement'] = nil
end

function wizard_panel_terrain_placement_update()
  local advantage = g_game_settings['tactical_advantage']
  local table_locked = g_game_settings['table locked']
  if (not table_locked) then
    table_locked = false
  end
  local table_can_be_locked = not table_locked
  UI.setAttribute("wizard_panel_terrain_placement_advantage", "text", advantage)
  UI.setAttribute("wizard_panel_terrain_placement_lock_table", "interactable", table_can_be_locked)
  if table_locked then
    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_terrain_placement_next", "interactable", true)
      end,
      1)
  end
end

function on_wizard_panel_terrain_placement_lock_table()
  fix_terrain_and_lock()
  destroy_all_terrain_bags()
end


function wizard_show_panel_terrain_placement()
  wizard_panel_terrain_placement_update()
  wizard_show_panel("wizard_panel_terrain_placement")
  g_wizard_exit_panel_fn = wizard_panel_exit_terrain_placement
  g_game_table_callbacks['wizard_panel_terrain_placement'] = wizard_panel_terrain_placement_update
  draw_deployment_lines()
end

-------------------
------------------- Camps
-------------------

function on_wizard_panel_camps_previous()
  wizard_show_panel_terrain_placement()
end


function on_wizard_panel_camps_next()
  wizard_show_panel_deploy_troops()
end


function wizard_panel_exit_camps()
  remove_deployment_lines()
end


function wizard_show_panel_camps()
  local advantage = g_game_settings['tactical_advantage']
  local disadvantage = get_tactical_disadvantage()
  UI.setAttribute("wizard_panel_camps_disadvantage", "text", disadvantage)
  UI.setAttribute("wizard_panel_camps_advantage", "text", advantage)
  wizard_show_panel("wizard_panel_camps")
  g_wizard_exit_panel_fn = wizard_panel_exit_camps
  draw_deployment_lines()
end

-------------------
------------------- Deploy Troops
-------------------

function on_wizard_panel_deploy_troops_previous()
  wizard_show_panel_camps()
end


function on_wizard_panel_deploy_troops_next()
  wizard_show_panel_first_move()
end


function wizard_panel_exit_deploy_troops()
  remove_deployment_lines()
end


function wizard_show_panel_deploy_troops()
  local advantage = g_game_settings['tactical_advantage']
  local disadvantage = get_tactical_disadvantage()
  UI.setAttribute("wizard_panel_deploy_troops_disadvantage_center_line", "text", disadvantage)
  UI.setAttribute("wizard_panel_deploy_troops_advantage", "text", advantage)
  UI.setAttribute("wizard_panel_deploy_troops_disadvantage_remainder", "text", disadvantage)
  wizard_show_panel("wizard_panel_deploy_troops")
  g_wizard_exit_panel_fn = wizard_panel_exit_deploy_troops
  draw_deployment_lines()
end



-------------------
------------------- First Move
-------------------

function on_wizard_panel_first_move_previous()
  wizard_show_panel_deploy_troops()
  g_game_settings['use_army_builder'] = true
  update_points_zones()
end


function on_wizard_panel_first_move_next()
  wizard_hide()
end


function wizard_show_panel_first_move()
  local advantage = g_game_settings['tactical_advantage']
  UI.setAttribute("wizard_panel_first_move_advantage", "text", advantage)
  wizard_show_panel("wizard_panel_first_move")
  g_game_settings['use_army_builder'] = false
  update_points_zones()
end


-------------------
-------------------
-------------------
