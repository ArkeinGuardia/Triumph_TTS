
triumph_terrain_nb_pieces = {}
triumph_terrain_nb_pieces['steepe']={1,1,1,2,2,3,3,4,4,5,5}
triumph_terrain_nb_pieces['dry']=triumph_terrain_nb_pieces['steepe']
triumph_terrain_nb_pieces['forest']={2,3,3,4,4,5,5,6,6,6,6}
triumph_terrain_nb_pieces['marsh']=triumph_terrain_nb_pieces['forest']
triumph_terrain_nb_pieces['arable']={1,2,2,3,3,4,4,5,5,6,6}
triumph_terrain_nb_pieces['hilly']=triumph_terrain_nb_pieces['arable']
triumph_terrain_nb_pieces['delta']=triumph_terrain_nb_pieces['arable']

grand_triumph_terrain_nb_pieces = {}
grand_triumph_terrain_nb_pieces['steepe']={1,1,2,3,4,5,6,6,7,7,9}
grand_triumph_terrain_nb_pieces['dry']=grand_triumph_terrain_nb_pieces['steepe']
grand_triumph_terrain_nb_pieces['forest']={4,5,6,6,7,7,8,9,10,10,10}
grand_triumph_terrain_nb_pieces['marsh']=grand_triumph_terrain_nb_pieces['forest']
grand_triumph_terrain_nb_pieces['arable']={2,3,4,5,6,6,7,7,8,9,10}
grand_triumph_terrain_nb_pieces['hilly']=grand_triumph_terrain_nb_pieces['arable']
grand_triumph_terrain_nb_pieces['delta']=grand_triumph_terrain_nb_pieces['arable']

terrain_manditory = {}
terrain_manditory['steepe']={{type="Gentle hills"}}
terrain_manditory['dry']={{type="Rough"}}
terrain_manditory['forest']={{type="Woods"}}
terrain_manditory['marsh']={{type="Marsh"}}
terrain_manditory['arable']={{type="Village"}}
terrain_manditory['hilly']={{type="Steep hills"}}
terrain_manditory['delta']={{type="Coast"}}
terrain_optional = {}
terrain_optional['steepe']={
  {type="Stream"},
  {type="Rough"},
  {type="Woods", max=1},
  {type={"Gentle hills"}}
}
terrain_optional['dry']={
  {type="Dunes"},
  {type="Steep Hills"},
  {type="Oasis"},
  {type="Rough"}
}
terrain_optional['forest']={
  {type="Stream"},
  {type="Marsh"},
  {type="Wooded Hills"},
  {type="Woods"}
}
terrain_optional['marsh']={
  {type="Woods"},
  {type="Stream"},
  {type="Coast"},
  {type="Marsh"}
}
terrain_optional['arable']={
  {type="Stream"},
  {type="Steep Hills"},
  {type="Gentle Hills", max=1},
  {type="Woods"},
  {type="Wooded Hills"},
  {type="Coast"},
  {type="Rough"},
  {type="Ploughed Fields"}
}
terrain_optional['hilly']={
  {type="Stream"},
  {type="Woods"},
  {type="Wooded Hills"},
  {type="Steep Hills"}
}
terrain_optional['delta']={
  {type="Marsh"},
  {type="Dunes"},
  {type="Village"}
}

local terrain_bag_names = {
  "Dunes Ordinary Small",
  "Woods Ordinary Small",
  "Steep Hills Ordinary Small",
  "Gentle Hills Ordinary Small",
  "Wooded Hills Ordinary Small",
  "Rough Ordinary Small",
  "Marshes Ordinary Small",
  "Oasis Ordinary Small",
  "Villages Ordinary Small",
  "Ploughed Fields Ordinary Small",

  "Dunes Ordinary Large",
  "Woods Ordinary Large",
  "Steep Hills Ordinary Large",
  "Gentle Hills Ordinary Large",
  "Wooded Hills Ordinary Large",
  "Rough Ordinary Large",
  "Marshes Ordinary Large",
  "Oasis Ordinary Large",
  "Villages Ordinary Large",
  "Ploughed Fields Ordinary Large",

  "Dunes Edge Small",
  "Woods Edge Small",
  "Steep Hills Edge Small",
  "Gentle Hills Edge Small",
  "Wooded Hills Edge Small",
  "Rough Edge Small",
  "Marshes Edge Small",
  "Oasis Edge Small",
  "Villages Edge Small",
  "Ploughed Fields Edge Small",

  "Dunes Edge Large",
  "Woods Edge Large",
  "Steep Hills Edge Large",
  "Gentle Hills Edge Large",
  "Wooded Hills Edge Large",
  "Rough Edge Large",
  "Marshes Edge Large",
  "Oasis Edge Large",
  "Villages Edge Large",
  "Ploughed Fields Edge Large",

  "Coasts",
  "Streams"
}

-- used: Set of names of the terrain that can be placed on the table_type.
--  e.g. "Woods"
-- bag_name: Name of a bag to check. e.g. "Gentle Hills Ordinary Small"
function is_terrain_bag_used(used, bag_name)
  for terrain,_ in pairs(used) do
    if  str_starts_with(bag_name, terrain) then
      return true
    end
  end
  return false
end

function destroy_unused_terrain_bags()
  local topography = g_game_settings['topography']
  -- build up the used terrain
  local used = {}
  for _,terrain in pairs(terrain_manditory[topography]) do
    local type = terrain['type']
    used[type] = true
  end
  for _,terrain in pairs(terrain_optional[topography]) do
    local type = terrain['type']
    used[type] = true
  end
  for _,bag_name in pairs(terrain_bag_names) do
    local bag = get_object_by_name(bag_name)
    if nil == bag then
      print_debug("Unable to find terrain bag " .. bag_name)
    else
      if not is_terrain_bag_used(used, bag_name) then
        bag.destruct()
      end
    end
  end
end

function destroy_all_terrain_bags()
  for _,bag_name in pairs(terrain_bag_names) do
    local bag = get_object_by_name(bag_name)
    if nil ~= bag then
      bag.destruct()
    end
  end
end

function get_terrain_nb_pieces()
  if g_game_settings['is_grand_triumph']  then
    return grand_triumph_terrain_nb_pieces
  else
    return triumph_terrain_nb_pieces
  end
end



-- name: ID of panel in XML file.
-- exit: function to call when the panel changes from active to inactive
-- enter: function to call when the panel changes from inactive to active
wizard_panels = {}

function get_tactical_disadvantage()
  local advantage = g_game_settings['tactical_advantage']
  if advantage == nil then
    print_error("tactical_advantage has not been set")
    return "red"
  end
  if advantage == "red" then
    return "blue"
  else
    return "red"
  end
end


-- Entry from wizard_panels that is currently showing.
g_current_showing_wizard_panel = nil


function wizard_show_panel(panel_name)
  -- cleanup the current panel
  if nil ~= g_current_showing_wizard_panel then
    -- hide the panel so there can be no more UI input
    UI.setAttribute(g_current_showing_wizard_panel['name'], "active", false)
    local exit_fn = g_current_showing_wizard_panel['exit']
    if nil ~= exit_fn then
      exit_fn()
    end
  end
  g_current_showing_wizard_panel = nil

  -- Find the new panel
  local wizard_active = false
  for _,panel in pairs(wizard_panels) do
    local panel_active = (panel['name'] == panel_name)
    wizard_active = wizard_active or panel_active
    if panel_active then
      g_current_showing_wizard_panel = panel
    end
  end
  UI.setAttribute("panel_wizard_bg", "active", wizard_active)
  g_game_settings['wizard_page'] = panel_name

  if nil ~= g_current_showing_wizard_panel then
    -- prepare the panel
    local enter_fn = g_current_showing_wizard_panel['enter']
    if nil ~= enter_fn then
      enter_fn()
    end
    -- show the panel
    local current_panel_name = g_current_showing_wizard_panel['name']
    UI.setAttribute(current_panel_name, "active", true)
  end
end

function wizard_hide()
  wizard_show_panel("none")
  update_current_ui()
end

function is_wizard_showing()
  if not g_game_settings['wizard_page'] then
    return false
  end
  if g_game_settings['wizard_page'] == "none" then
    return false
  end
  return true
end


-------------------
------------------- Game Panel
-------------------

function wizard_show_panel_game()
  wizard_show_panel("wizard_panel_game")
end

function wizard_pannel_game_update()
  local is_grand_triumph = g_game_settings['is_grand_triumph']
  if is_grand_triumph == nil then
    UI.setAttribute("wizard_togglegroup_game_triumph", "isOn", false)
    UI.setAttribute("wizard_togglegroup_game_grand_triumph", "isOn", false)
    return
  end

  UI.setAttribute("wizard_togglegroup_game_triumph", "isOn", not is_grand_triumph)
  UI.setAttribute("wizard_togglegroup_game_grand_triumph", "isOn", is_grand_triumph)

  local next_enabled = (g_game_settings['is_grand_triumph'] ~= nil)
  UI.setAttribute("wizard_panel_game_next", "interactable", next_enabled)
end

function wizard_panel_game_enter()
  wizard_pannel_game_update()
end

function wizard_panel_game_exit()
  spawn_all_dice()
end

function on_wizard_togglegroup_game(player, value, id)
  g_game_settings['is_grand_triumph'] = (value == "1")
  wizard_pannel_game_update()
end

function on_wizard_button_forward_to_select_armies()
      wizard_show_panel_select_armies()
end

table.insert(wizard_panels, {name="wizard_panel_game", exit=wizard_panel_game_exit, enter=wizard_panel_game_enter})


-------------------
------------------- Select armies
-------------------


function on_wizard_panel_select_armies_previous()
  wizard_show_panel_game()
end

function on_wizard_panel_select_armies_next()
  wizard_show_panel_select_troops()
end

function wizard_panel_select_armies_update()
  local enable_next = (g_game_settings['army_id'] ~= nil) and (g_game_settings['army_id'] ['red'] ~= nil) and (g_game_settings['army_id'] ['blue'] ~= nil)
  UI.setAttribute("wizard_panel_select_armies_next", "interactable", enable_next)
end

function wizard_show_panel_select_armies()
  wizard_show_panel("wizard_panel_select_armies")
end

function wizard_panel_select_armies_enter()
  g_load_army_callback = wizard_panel_select_armies_update
  wizard_panel_select_armies_update()
end

function wizard_panel_select_armies_exit()
  g_load_army_callback = nil
end


table.insert(wizard_panels, {name="wizard_panel_select_armies", exit=wizard_panel_select_armies_exit, enter=wizard_panel_select_armies_enter})

-------------------
------------------- Select troops
-------------------

function wizard_show_panel_select_troops()
  wizard_show_panel("wizard_panel_select_troops")
end


function on_wizard_panel_select_troops_previous()
  wizard_show_panel_select_armies()
end


function on_wizard_panel_select_troops_next()
  wizard_show_panel_invader()
end

function wizard_panel_select_troops_enter()
  -- make the bases invisible to the other player
  g_movement_reporting_enabled = false
  g_gizmo_drawing_disabled = true
  for _, base in pairs(getAllObjects()) do
    if is_base_blue_player(base) then
      base.setInvisibleTo({"Red"})
    elseif is_base_red_player(base) then
      base.setInvisibleTo({"Blue"})
    end
  end

  g_game_settings['use_army_builder'] = true
end

function wizard_panel_select_troops_exit()
  -- make the bases visible to everyone
  for _, obj in pairs(getAllObjects()) do
    obj.setInvisibleTo({})
  end
  g_movement_reporting_enabled = true
  g_gizmo_drawing_disabled = false
end

table.insert(wizard_panels, {name="wizard_panel_select_troops", exit=wizard_panel_select_troops_exit, enter=wizard_panel_select_troops_enter})

-------------------
------------------- Invader
-------------------

function wizard_show_panel_invader()
  wizard_show_panel("wizard_panel_invader")
end


function wizard_panel_invader_enter()
  wizard_panel_invader_set_ratings()
  g_dice_callbacks['invasion_dice_rolled'] = on_invasion_dice_rolled
  update_invasion_wizard_page()
end

function wizard_panel_exit_invader()
  g_dice_callbacks["invasion_dice_rolled"] = nil
end

-- Disable the invasion ratings that do not apply to an army.
-- color: Player color for the army
function wizard_panel_invader_set_ratings_for_color(color)
  local army_id = g_game_settings['army_id'] [color]
  local army = army[army_id]
  local data = army['data']
  local invasionRatings = data['invasionRatings']
  for i=0,5,1 do
    local id = "wizard_togglegroup_invasion_" .. color .. "_" .. tostring(i)
    UI.setAttribute(id, "active", "false")
  end
  for _,value in ipairs(invasionRatings) do
    local id = "wizard_togglegroup_invasion_" .. color .. "_" .. tostring(value)
    UI.setAttribute(id, "active", "true")
  end
end

-- Disable the invastion ratings that do not apply for the armies selected.
function wizard_panel_invader_set_ratings()
  wizard_panel_invader_set_ratings_for_color('red')
  wizard_panel_invader_set_ratings_for_color('blue')
end

function on_invasion_dice_rolled(dice_color, value)
  if g_game_settings['invader'] == nil then
    local id = "text_" .. dice_color .. "_invasion_roll_value"
    UI.setAttribute(id, "text", tostring(value))
    update_invasion_wizard_page()
  end
end

function on_button_red_invasion_roll()
  roll_dice('red')
end

function on_button_blue_invasion_roll()
  roll_dice('blue')
end

function on_red_invasion_rating_selected(player, value, id)
  local rating = tonumber(value)
  g_game_settings['invasion_rating']['red'] = rating
  update_invasion_wizard_page()
end

function on_blue_invasion_rating_selected(player, value, id)
  local rating = tonumber(value)
  g_game_settings['invasion_rating']['blue'] = rating
  update_invasion_wizard_page()
end

-- Update the score box for the invasion wizard
-- color: "red" or "blue"
-- return: total or nil if the value is not yet ready
function update_invasion_wizard_score(color)
  local score_id = color .. "_invasion_score"
  local dice_id = "text_" .. color .. "_invasion_roll_value"
  local dice_str = UI.getAttribute(dice_id, "text")
  if dice_str == nil or dice_str == "" then
    return nil
  end
  local dice = tonumber(dice_str)
  if dice == nil then
    UI.setAttribute(score_id, "text", "")
    return nil
  end
  if g_game_settings['invasion_rating'][color] == nil then
    return nil
  end

   local rating = g_game_settings['invasion_rating'][color]
   if rating == nil then
     UI.setAttribute(score_id, "text", "")
     return nil
   end

   local score = dice + rating
   UI.setAttribute(score_id, "text", tostring(score))
   return score
end

function do_update_invasion_wizard_page()
  if g_game_settings['invader'] ~= nil then
    g_dice_callbacks['invasion_dice_rolled'] = nil

    UI.setAttribute("red_invasion_rating", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_0", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_1", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_2", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_3", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_4", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_red_5", "interactable", false)
    UI.setAttribute("button_red_invasion_roll", "interactable", false)

    UI.setAttribute("blue_invasion_rating", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_0", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_1", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_2", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_3", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_4", "interactable", false)
    UI.setAttribute("wizard_togglegroup_invasion_blue_5", "interactable", false)
    UI.setAttribute("button_blue_invasion_roll", "interactable", false)

    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_invader_next", "interactable", true)
      end,
      1)

    return
  end

  local red_score = update_invasion_wizard_score("red")
  local blue_score = update_invasion_wizard_score("blue")
  if red_score == nil or blue_score == nil then
    UI.setAttribute("invader", "text", "")
    UI.setAttribute("wizard_panel_invader_next", "interactable", false)
    return
  end
  if red_score == blue_score then
    UI.setAttribute("invader", "text", "tie, roll again")
    UI.setAttribute("text_blue_invasion_roll_value", "text", "")
    UI.setAttribute("text_red_invasion_roll_value", "text", "")
    UI.setAttribute("wizard_panel_invader_next", "interactable", false)
    g_game_settings['invader']=nil
    g_dice_callbacks['invasion_dice_rolled'] = nil
    -- Wait a frame for the UI elements to be updated before 
    -- they can be queried
    Wait.frames(
      function()
        g_dice_callbacks['invasion_dice_rolled'] = on_invasion_dice_rolled
        do_update_invasion_wizard_page()
      end,
      1)
    return
  end
  if red_score > blue_score then
    UI.setAttribute("invader", "text", "Red invades")
    g_game_settings['invader'] = "red"
    print_info("Red invades")
    g_game_settings['invader']="red"
  else
    UI.setAttribute("invader", "text", "Blue invades")
    g_game_settings['invader'] = "blue"
    print_info("Blue invades")
    g_game_settings['invader']="blue"
  end
  do_update_invasion_wizard_page()

  Wait.frames(
    function()
      UI.setAttribute("wizard_panel_invader_next", "interactable", true)
    end,
    1)

end


function update_invasion_wizard_page()
  -- Need to wait one frame for the UI elements to update
  -- before we can query them
  Wait.frames(
    function()
      do_update_invasion_wizard_page()
    end,
    1)
end

function on_wizard_panel_invader_next()
  wizard_show_panel_topography()
end

function on_wizard_panel_invader_previous()
  wizard_show_panel_select_troops()
end

table.insert(wizard_panels, {name="wizard_panel_invader", exit=wizard_panel_exit_invader, enter=wizard_panel_invader_enter})


-------------------
------------------- Topography
-------------------

g_topographies = {'arable', 'forest', 'hilly', 'dry', 'steepe', 'marsh', 'delta'}

function wizard_show_panel_topography()
  wizard_show_panel("wizard_panel_topography")
end

function wizard_panel_topography_enter()
  -- set the table type before populating otherwise it will be set to zero.
  local defender
  if g_game_settings['invader']=='blue' then
    defender = 'red'
  else
    defender = 'blue'
  end
  local army_id = g_game_settings['army_id'] [defender]
  local army = army[army_id]
  local data = army['data']
  local homeTopographies =  data['homeTopographies']
  for table_type,topo in ipairs(g_topographies) do
    local active =  find_in_array(homeTopographies, topo, str_equals_case_insensitive)
    if active then
      g_game_settings["table type"] = table_type
    end
  end
  UI.setAttribute("wizard_topgraphy_defender", "text", defender)
  for table_type,topo in ipairs(g_topographies) do
      local active =  find_in_array(homeTopographies, topo, str_equals_case_insensitive)
      local id = "wizard_topography_" .. topo
      UI.setAttribute(id, "active", tostring(active))
  end
  wizard_panel_topography_update()
end

function on_wizard_topography_selected(player, value, id)
  g_game_settings["table type"] = tonumber(value)
  g_game_settings['topography'] = g_topographies[g_game_settings["table type"]+1]
  wizard_panel_topography_update()
end

function on_wizard_panel_topography_spawn_table()
  if g_game_settings['topography'] == nil then
    return
  end
  load_table(g_game_settings["table type"])

  Wait.frames(
    function()
      g_game_settings['table_spawned'] = true
      destroy_unused_terrain_bags()
      wizard_panel_topography_update()
    end,
    1)
end

function wizard_panel_topography_update()
  if nil ~= g_game_settings["topography"] then
    -- select the topography that has been previously chosen
    local selected_id = "wizard_topography_" .. g_game_settings["topography"]
    for _,topo in ipairs(g_topographies) do
      local id = "wizard_topography_" .. topo
      if selected_id == id then
        UI.setAttribute(id, "isOn", true)
      else
        UI.setAttribute(id, "isOn", false)
      end
    end
  end
  if (nil ~= g_game_settings['table_spawned'])  and (nil ~= g_game_settings['topography']) then
    UI.setAttribute("wizard_topography_arable", "interactable", false)
    UI.setAttribute("wizard_topography_forest", "interactable", false)
    UI.setAttribute("wizard_topography_hilly", "interactable", false)
    UI.setAttribute("wizard_topography_dry", "interactable", false)
    UI.setAttribute("wizard_topography_steepe", "interactable", false)
    UI.setAttribute("wizard_topography_delta", "interactable", false)
    UI.setAttribute("wizard_topography_marsh", "interactable", false)
    UI.setAttribute("wizard_panel_topography_spawn_table", "interactable", false)

    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_topography_next", "interactable", true)
      end,
      1)
      return
  end

  if (nil == g_game_settings['topography']) then
    UI.setAttribute("wizard_panel_topography_spawn_table", "interactable", false)
  else
    UI.setAttribute("wizard_panel_topography_spawn_table", "interactable", true)
  end

end

function on_wizard_panel_topography_previous()
  wizard_show_panel_invader()
end

function on_wizard_panel_topography_next()
  wizard_show_panel_tactical_advantage()
end

function wizard_panel_topography_exit()
  g_load_table_callback = nil
end

table.insert(wizard_panels, {name="wizard_panel_topography", exit=wizard_panel_topography_exit, enter=wizard_panel_topography_enter})

-------------------
------------------- Tatucal Advantage
-------------------

function wizard_show_panel_tactical_advantage()
  wizard_show_panel("wizard_panel_tactical_advantage")
end

function wizard_panel_tactical_advantage_enter()
  wizard_panel_tactical_advantage_update_manueuver_ratings()
  g_dice_callbacks['tactical_advantage_dice_rolled'] = on_tactical_advantage_dice_rolled
  do_update_tactical_advantage_wizard_page()
end

function wizard_panel_exit_tactical_advantage()
  g_dice_callbacks["tactical_advantage_dice_rolled"] = nil
end

function on_wizard_panel_tactical_advantage_previous()
  wizard_show_panel_topography()
end

function on_wizard_panel_tactical_advantage_next()
  wizard_show_panel_terrain_pieces_roll()
end

function on_tactical_advantage_dice_rolled(dice_color, value)
  if nil == g_game_settings["tactical_advantage_score"] then
    local id = "wizard_maneuver_roll_value_" .. dice_color
    UI.setAttribute(id, "text", tostring(value))
    g_game_settings[id] = value
    wizard_panel_tactical_advantage_update()
  end
end

function on_wizard_red_maneuver_rating_selected(player, value, id)
  print_info("Red maneuver rating " .. tostring(value))
  local maneuverRatings =  get_maneuver_ratings_for_color('red')
  local rating = maneuverRatings[tonumber(value)]
  g_game_settings['wizard_maneuver_rating_red'] = rating
  wizard_panel_tactical_advantage_update()
end

function on_wizard_blue_maneuver_rating_selected(player, value, id)
  print_info("Blue maneuver rating " .. tostring(value))
  local maneuverRatings =  get_maneuver_ratings_for_color('blue')
  local rating = maneuverRatings[tonumber(value)]
  g_game_settings['wizard_maneuver_rating_blue'] = rating
  wizard_panel_tactical_advantage_update()
end

function on_wizard_button_red_maneuver_roll()
  roll_dice('red')
end

function on_wizard_button_blue_maneuver_roll()
  roll_dice('blue')
end

-- color: either "blue" or "red"
function get_maneuver_ratings_for_color(color)
  local army_id = g_game_settings['army_id'] [color]
  local army = army[army_id]
  local data = army['data']
  local maneuverRatings =  data['maneuverRatings']
  return maneuverRatings
end

-- xml: XML table to modify
-- color:  Color of the player whose maneuver rating we are updating
-- either 'blue' or 'red'
function wizard_tactical_advantage_update_maneuver_rating(xml, color)
  local maneuverRatings =  get_maneuver_ratings_for_color(color)
  local menu_id = "wizard_maneuver_rating_" .. color
  local options = {}
  local selected_index = nil
  for index,maneuverRating in ipairs(maneuverRatings) do
    table.insert(options, tostring(maneuverRating))
    if g_game_settings[menu_id] == maneuverRating then
      selected_index = index
    end
  end
  if selected_index == nil then
    selected_index = 1
    g_game_settings[menu_id] = maneuverRatings[selected_index]
  end
  set_options_dropdown_by_id_xml(xml, menu_id, options, selected_index)
end


function wizard_panel_tactical_advantage_update_manueuver_ratings()
  local xml = UI.getXmlTable()
  wizard_tactical_advantage_update_maneuver_rating(xml, "red")
  wizard_tactical_advantage_update_maneuver_rating(xml, "blue")
  UI.setXmlTable(xml)
end

function spawn_flank_march_card(color)
  local face_URL
  local z_pos = 4.59
  local y_rotation = 0
  if color == "red" then
    face_URL=g_assets['flank_march_card_red']
    z_pos = -z_pos
    y_rotation = 180
  else
    face_URL=g_assets['flank_march_card_blue']
  end
  -- Card is sized to be 4 MU, which is the limits of entering on
  -- a flank march
  local flank_card_data =
   {
     Name= "CardCustom",
     Transform= {
       posX= 0,
       posY= 3.01,
       posZ= z_pos,
       rotX= 0,
       rotY= y_rotation,
       rotZ= 180.0,
       scaleX= 1,
       scaleY= 1,
       scaleZ= 1
     },
     ColorDiffuse= {
       r= 1.0,
       g= 0.0,
       b= 0.0
     },
   }
  local flank_card_custom = function(flank_card)
    flank_card.setName("flank march card")
    set_decoration_for_obj(flank_card, "flank_march_card", color)
    flank_card.setCustomObject( {
       type=1,
       face=face_URL,
       back=face_URL } )
    local size = flank_card.getBounds()['size']
    local z_size = size.z
    local desired_size = from_mu_to_in(4)
    local z_scale = desired_size/ z_size
    y_scale=5
    flank_card.scale(z_scale)
    flank_card.reload()
  end
  local flank_card = spawnObjectData( { data=flank_card_data, callback_function=flank_card_custom})
end

function wizard_update_flank_march_for_color(color)
  local flank_id = color .. "_flank_march"
  if g_game_settings[flank_id] ~= nil then
    return
  end
  local rating_id = "wizard_maneuver_rating_" .. color
  local maneuver_rating = g_game_settings[rating_id]
  if maneuver_rating == nil then
    return
  end
  local dice_id = "wizard_maneuver_roll_value_" .. color
  local dice = g_game_settings[dice_id]
  if dice == nil then
    return
  end
  local flank = ((dice == 1) or (dice < maneuver_rating))

  g_game_settings[flank_id] = flank
  local wizard_id = "wizard_" .. flank_id
  if flank then
    UI.setAttribute(wizard_id, "text", "Flank March")
    print_info(color .. " is eligible for flank march.")
    spawn_flank_march_card(color)
  else
    UI.setAttribute(wizard_id, "text", "")
    print_info("No flank march for " .. color)
  end
end

-- Update the score box for the tactical advanage  wizard
-- color: "red" or "blue"
-- return: total or nil if the value is not yet ready
function update_tactical_maneuver_wizard_score(color)
  local score_id = "wizard_" .. color .. "_maneuver_score"
  local rating_id = "wizard_maneuver_rating_" .. color
  local rating = g_game_settings[rating_id]
  if rating == nil then
    UI.setAttribute(score_id, "text", "")
    return nil
  end

  local dice_id = "wizard_maneuver_roll_value_" .. color
  local dice = g_game_settings[dice_id]
  if dice == nil then
    UI.setAttribute(score_id, "text", "")
    return nil
  end

  local score = dice + rating
  UI.setAttribute(score_id, "text", tostring(score))
  return score
end

function do_update_tactical_advantage_wizard_page()
  if g_game_settings["tactical_advantage_score"] ~= nil then
    UI.setAttribute("wizard_maneuver_rating_red", "interactable", false)
    UI.setAttribute("wizard_maneuver_rating_blue", "interactable", false)
    UI.setAttribute("wizard_button_red_maneuver_roll", "interactable", false)
    UI.setAttribute("wizard_button_blue_maneuver_roll", "interactable", false)
    g_dice_callbacks['tactical_advantage_dice_rolled'] = nil

    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_tactical_advantage_next", "interactable", true)
      end,
      1)

    return
  end

  wizard_panel_tactical_advantage_update_manueuver_ratings()

  local red_score = update_tactical_maneuver_wizard_score("red")
  local blue_score = update_tactical_maneuver_wizard_score("blue")
  wizard_update_flank_march_for_color('red')
  wizard_update_flank_march_for_color('blue')
  if red_score == nil or blue_score == nil then
    UI.setAttribute("wizard_text_tactical_advantage_player", "text", "")
    UI.setAttribute("wizard_text_tactical_advantage_score", "text", "")
    return
  end
  if red_score == blue_score then
    UI.setAttribute("wizard_text_tactical_advantage_player", "text", "tie, roll again")
    UI.setAttribute("wizard_maneuver_roll_value_red", "text", nil)
    UI.setAttribute("wizard_maneuver_roll_value_blue", "text", nil)
    return
  end
  local advantage = math.abs(red_score - blue_score)
  g_game_settings["tactical_advantage_score"] = advantage
  UI.setAttribute("wizard_text_tactical_advantage_score", "text", tostring(advantage))
  if red_score > blue_score then
      UI.setAttribute("wizard_text_tactical_advantage_player", "text", "Red tactical advantage: ")
      g_game_settings['tactical_advantage'] = "red"
  else
     UI.setAttribute("wizard_text_tactical_advantage_player", "text", "Blue tactical advantage: ")
     g_game_settings['tactical_advantage'] = "blue"
  end
  g_dice_callbacks['tactical_advantage_dice_rolled'] =  nil
  UI.setAttribute("wizard_panel_tactical_advantage_next", "interactable", true)
  print_important("tactical advantage " .. g_game_settings['tactical_advantage'] ..
    ' ' .. tostring(g_game_settings["tactical_advantage_score"]))
  do_update_tactical_advantage_wizard_page()
end

function wizard_panel_tactical_advantage_update()
  -- Need to wait one frame for the UI elements to update
  -- before we can query them
  Wait.frames(
    function()
      do_update_tactical_advantage_wizard_page()
    end,
    1)
end

table.insert(wizard_panels, {name="wizard_panel_tactical_advantage", exit=wizard_panel_exit_tactical_advantage, enter=wizard_panel_tactical_advantage_enter})

-------------------
------------------- terrain pieces roll
-------------------

function wizard_show_panel_terrain_pieces_roll()
  wizard_show_panel("wizard_panel_terrain_pieces_roll")
end

function wizard_panel_terrain_pieces_roll_enter()
  g_dice_callbacks['terrain_pieces_dice_rolled'] = on_terrain_pieces_dice_rolled
  wizard_panel_terrain_pieces_roll_update()
end

function wizard_panel_exit_terrain_pieces_roll()
  g_dice_callbacks["terrain_pieces_dice_rolled"] = nil
end

function on_wizard_panel_terrain_pieces_roll_previous()
  wizard_show_panel_tactical_advantage()
end


function on_wizard_panel_terrain_pieces_roll_next()
  wizard_show_panel_terrain_score()
end

function on_wizard_button_red_terrain_pieces_roll()
  roll_dice('red')
end

function on_wizard_button_blue_terrain_pieces_roll()
  roll_dice('blue')
end

function on_terrain_pieces_dice_rolled(dice_color, value)
  if nil == g_game_settings['terrain_score_high'] then
    local id = "wizard_terrain_pieces_roll_value_" .. dice_color
    UI.setAttribute(id, "text", tostring(value))
    g_game_settings[id] = value
  end
  wizard_panel_terrain_pieces_roll_update()
end


function wizard_panel_terrain_pieces_roll_update()
  if nil ~= g_game_settings['terrain_score_high'] then
    g_dice_callbacks['terrain_pieces_dice_rolled'] = nil
    UI.setAttribute("wizard_button_red_terrain_pieces", "interactable", false)
    UI.setAttribute("wizard_button_blue_terrain_pieces", "interactable", false)
    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_terrain_pieces_roll_next", "interactable", true)
      end,
      1)
    return
  end

  UI.setAttribute("wizard_panel_terrain_pieces_roll_tactical_advantage", "text",
    tostring(g_game_settings["tactical_advantage_score"]))
  if g_game_settings["wizard_terrain_pieces_roll_value_blue"] == nil or
     g_game_settings["wizard_terrain_pieces_roll_value_red"] == nil
  then
    UI.setAttribute("wizard_panel_terrain_pieces_roll_total", "text", "")
    UI.setAttribute("wizard_panel_terrain_pieces_roll_terrain_score", "text", "")
    return
  end
  local total = g_game_settings["wizard_terrain_pieces_roll_value_blue"] +
      g_game_settings["wizard_terrain_pieces_roll_value_red"]
  UI.setAttribute("wizard_panel_terrain_pieces_roll_total", "text", tostring(total))

  local low = total - g_game_settings["tactical_advantage_score"]
  local high = total + g_game_settings["tactical_advantage_score"]
  if low < 2 then
    low = 2
  end
  if high > 12 then
    high = 12
  end
  local terrain_score = "Terrain Score: " .. tostring(low) .. " - " .. tostring(high)
  UI.setAttribute("wizard_panel_terrain_pieces_roll_terrain_score", "text", terrain_score)

  g_game_settings['terrain_score_low'] = low
  g_game_settings['terrain_score_high'] = high
  wizard_panel_terrain_pieces_roll_update()
end

table.insert(wizard_panels, {name="wizard_panel_terrain_pieces_roll", exit=wizard_panel_exit_terrain_pieces_roll, enter=wizard_panel_terrain_pieces_roll_enter})

-------------------
------------------- nb terrain pieces selection
-------------------


-- is a coast required.  index+1 = terrain score
terrain_coast = {false,false,true,false,false,true,false,false,true,false,false}

function wizard_show_panel_terrain_score()
  wizard_show_panel("wizard_panel_terrain_score")
end

function on_wizard_panel_terrain_score_previous()
  wizard_show_panel_terrain_pieces_roll()
end


function on_wizard_panel_terrain_score_next()
  wizard_show_panel_terrain_selection()
end

function on_wizard_tarrain_score_selected(player, value, id)
  g_game_settings['terrain_score']  = tonumber(value) + 2
  local terrain_score = g_game_settings['terrain_score']
  g_game_settings['coast_allowed'] =  terrain_coast[terrain_score-1]
  wizard_panel_terrain_score_update()
end


function is_coast_supported(terrain_allowed) 
  for _, v in pairs(terrain_allowed) do
    if v['type'] == 'Coast' then
      return true
    end  
  end
  return false
end

function is_coast_available_for_topography(topography)
  local manditory_terrain_types = terrain_manditory[topography]
  if is_coast_supported(manditory_terrain_types) then
    return true
  end
  local optional_terrain_types = terrain_optional[topography]
  if is_coast_supported(optional_terrain_types) then
    return true
  end
  return false
end


function wizard_panel_terrain_score_enter()
  -- Remove coast for terrain where it is not allowed
  if not is_coast_available_for_topography(g_game_settings['topography']) then
    for score=2,12 , 1 do
      local id = "wizard_terrain_score_nb_coast_" .. tostring(score)
      UI.setAttribute(id, "text", '-')
    end
  end
  
  local terrain_nb_pieces = get_terrain_nb_pieces()

  -- Enable and disable the toggles for the terain score
  for score=2,g_game_settings['terrain_score_low']-1 , 1 do
    local id = "wizard_terrain_score_" .. tostring(score)
    UI.setAttribute(id, "active", false)
  end
  for score=g_game_settings['terrain_score_low'] ,g_game_settings['terrain_score_high'] , 1 do
    local id = "wizard_terrain_score_" .. tostring(score)
    UI.setAttribute(id, "active", true)
  end
  for score=g_game_settings['terrain_score_high']+1 ,12, 1 do
    local id = "wizard_terrain_score_" .. tostring(score)
    UI.setAttribute(id, "active", false)
  end

   -- Update the number of pieces based on the topography
  local topography =  g_game_settings['topography']
  for score=2,12,1 do
    local id = "wizard_terrain_score_nb_pieces_" .. tostring(score)
    local value = terrain_nb_pieces[topography][score-1]
    UI.setAttribute(id, "text", tostring(value))
  end
  wizard_panel_terrain_score_update()
end

function wizard_panel_exit_terrain_score()
  local terrain_nb_pieces = get_terrain_nb_pieces()

  local terrain_score = g_game_settings['terrain_score']
  local topography =  g_game_settings['topography']
  local nb_pieces = terrain_nb_pieces[topography][terrain_score-1]
  local coast
  if g_game_settings['coast_allowed'] then
    coast = " coast"
  else
    coast = ""
  end
  print_important("terrain score: " .. tostring(terrain_score) .. " nb pieces: " .. tostring(nb_pieces) ..  coast)
end

function wizard_panel_terrain_score_update()
  if g_game_settings['terrain_score'] ~= nil then
    UI.setAttribute("wizard_panel_terrain_score_next", "interactable", true)
    local id = "wizard_terrain_score_" .. tostring(g_game_settings['terrain_score'])
    UI.setAttribute(id, "isOn", true)
  end
end

table.insert(wizard_panels, {name="wizard_panel_terrain_score", exit=wizard_panel_exit_terrain_score, enter=wizard_panel_terrain_score_enter})

-------------------
------------------- Terrain Selection
-------------------


-- terrain_list: an entery from the terrain_optional table_type
-- return: string for human consumption
function format_terrain_list(terrain_list)
  local result = ""
  local first = true
  for _,terrain in pairs(terrain_list) do
    if not first then
      result = result .. ", "
    end
    first = false
    result = result .. terrain['type']
    if nil ~= terrain['max'] then
      result = result .. "(" .. tostring(terrain['max']) .. ")"
    end
  end
  return result
end


function on_wizard_panel_terrain_selection_previous()
  wizard_show_panel_terrain_score()
end


function on_wizard_panel_terrain_selection_next()
  wizard_show_panel_terrain_placement()
end


function wizard_show_panel_terrain_selection()
  wizard_show_panel("wizard_panel_terrain_selection")
  wizard_panel_terrain_selection_enter()
end

function wizard_panel_terrain_selection_enter()
  local terrain_nb_pieces = get_terrain_nb_pieces()

  local advantage = g_game_settings['tactical_advantage']
  local terrain_score = g_game_settings['terrain_score']
  local topography =  g_game_settings['topography']
  local nb_pieces = terrain_nb_pieces[topography][terrain_score-1]
  local nb_optional_pieces = nb_pieces - 1
  UI.setAttribute("wizard_terrain_selection_advantage", "text", advantage);
  UI.setAttribute("wizard_terrain_selection_topography", "text", topography);
  UI.setAttribute("wizard_terrain_selection_terrain_score", "text", tostring(terrain_score));
  local coast
  if g_game_settings['coast_allowed'] then
    coast = " coast allowed"
  else
    coast = ""
  end
  UI.setAttribute("wizard_terrain_selection_coast", "text", coast);
  UI.setAttribute("wizard_terrain_selection_manditory", "text",
    format_terrain_list(terrain_manditory[topography]));
  UI.setAttribute("wizard_terrain_selection_optional_nb_pieces", "text", tostring(nb_optional_pieces));
  if nb_optional_pieces <= 0 then
    UI.setAttribute("wizard_terrain_selection_optional", "text", "");
  else
    UI.setAttribute("wizard_terrain_selection_optional", "text",
      format_terrain_list( terrain_optional[topography]) );
  end
end

table.insert(wizard_panels, {name="wizard_panel_terrain_selection", enter=wizard_panel_terrain_selection_enter })

-------------------
------------------- Terrain Placement
-------------------

function on_wizard_panel_terrain_placement_previous()
  wizard_show_panel_terrain_selection()
end


function on_wizard_panel_terrain_placement_next()
  wizard_show_panel_terrain_lock()
end


function wizard_panel_exit_terrain_placement()
  g_game_settings['show_deployment_lines']['wizard'] = nil
  update_deployment_lines()
  g_game_table_callbacks['wizard_panel_terrain_placement'] = nil
end

function wizard_panel_terrain_placement_update()
  local advantage = g_game_settings['tactical_advantage']
  UI.setAttribute("wizard_panel_terrain_placement_advantage", "text", advantage)
end


function wizard_show_panel_terrain_placement()
  wizard_show_panel("wizard_panel_terrain_placement")
  wizard_panel_terrain_placement_update()
end

function wizard_panel_terrain_placement_enter()
  g_game_settings['show_deployment_lines']['wizard'] = true
  update_deployment_lines()
  g_game_table_callbacks['wizard_panel_terrain_placement'] = wizard_panel_terrain_placement_update
end

table.insert(wizard_panels, {name="wizard_panel_terrain_placement", exit=wizard_panel_exit_terrain_placement, enter=wizard_panel_terrain_placement_enter})

-------------------
------------------- Terrain Lock
-------------------

function on_wizard_panel_terrain_lock_previous()
  wizard_show_panel_terrain_placement()
end


function on_wizard_panel_terrain_lock_next()
  wizard_show_panel_camps()
end


function wizard_panel_exit_terrain_lock()
  g_game_settings['show_deployment_lines']['wizard'] = nil
  update_deployment_lines()
  g_game_table_callbacks['wizard_panel_terrain_lock'] = nil
end

function wizard_panel_terrain_lock_update()
  UI.setAttribute("wizard_panel_terrain_3d", "isOn", g_game_settings['3d_terrain'])
  UI.setAttribute("wizard_panel_terrain_decorations", "isOn", g_game_settings['terrain_decorations'])
  local table_locked = g_game_settings['table locked']
  if (not table_locked) then
    table_locked = false
  end
  local table_can_be_locked = not table_locked
  UI.setAttribute("wizard_panel_terrain_lock_table", "interactable", table_can_be_locked)
  if table_locked then
    Wait.frames(
      function()
        UI.setAttribute("wizard_panel_terrain_lock_next", "interactable", true)
      end,
      1)
  end
end

function wizard_panel_terrain_3d_changed(player, value, id)
  value = tostring(value)
  g_game_settings['3d_terrain'] = ((value == "true") or (value=="True"))
  print_debug("3d_terrain " .. tostring(g_game_settings['3d_terrain']))
  wizard_panel_terrain_lock_update()
end

function wizard_panel_terrain_decorations_changed(player, value, id)
  value = tostring(value)
  g_game_settings['terrain_decorations'] = ((value == "true") or (value=="True"))
  print_debug("terrain_decorations " .. tostring(g_game_settings['terrain_decorations']))
  wizard_panel_terrain_lock_update()
end

function on_wizard_panel_terrain_lock_table()
  fix_terrain_and_lock()
  destroy_all_terrain_bags()
end

function wizard_show_panel_terrain_lock()
  wizard_show_panel("wizard_panel_terrain_lock")
  wizard_panel_terrain_lock_update()
end

function wizard_panel_terrain_lock_enter()
  g_game_settings['show_deployment_lines']['wizard'] = true
  update_deployment_lines()
  g_game_table_callbacks['wizard_panel_terrain_lock'] = wizard_panel_terrain_lock_update
end

table.insert(wizard_panels, {name="wizard_panel_terrain_lock", exit=wizard_panel_exit_terrain_lock, enter=wizard_panel_terrain_lock_enter})


-------------------
------------------- Camps
-------------------

function on_wizard_panel_camps_previous()
  wizard_show_panel_terrain_placement()
end


function on_wizard_panel_camps_next()
  wizard_panel_show_panel_disadvantaged_center_deployment()
end


function wizard_panel_exit_camps()
  g_game_settings['show_deployment_lines']['wizard'] = nil
  update_deployment_lines()
end


function wizard_show_panel_camps()
  wizard_show_panel("wizard_panel_camps")
end

function wizard_panel_camps_enter()
  local advantage = g_game_settings['tactical_advantage']
  local disadvantage = get_tactical_disadvantage()
  UI.setAttribute("wizard_panel_camps_disadvantage", "text", disadvantage)
  UI.setAttribute("wizard_panel_camps_advantage", "text", advantage)
  g_game_settings['show_deployment_lines']['wizard'] = true
  update_deployment_lines()
end

table.insert(wizard_panels, {name="wizard_panel_camps", exit=wizard_panel_exit_camps, enter=wizard_panel_camps_enter})

-------------------
------------------- wizard_panel_disadventaged_center_deployment
-------------------

function on_wizard_panel_disadvantaged_center_deployment_previous()
  wizard_show_panel_camps()
end


function on_wizard_panel_disadvantaged_center_deployment_next()
  wizard_panel_advantaged_deployment_show()
end


function wizard_panel_exit_disadvantaged_center_deployment()
  g_game_settings['show_deployment_lines']['wizard'] = nil
  update_deployment_lines()
end


function wizard_panel_show_panel_disadvantaged_center_deployment()
  wizard_show_panel("wizard_panel_disadvantaged_center_deployment")
end

function wizard_panel_disadventaged_center_deployment_enter()
  local disadvantage = get_tactical_disadvantage()
  UI.setAttribute("wizard_panel_disadvantaged_center_deployment_who", "text", disadvantage)

  local flank = g_game_settings[ disadvantage .. "_flank_march"]
  UI.setAttribute("wizard_panel_disadventaged_center_deployment_flank_march", "active", flank)


  local prepared_defenses = get_all_prepared_defenses()
  local players_prepared_defenses = filter_bases_by_player_color(prepared_defenses, disadvantage)
  local show_lock = not is_table_empty(players_prepared_defenses)
  UI.setAttribute("wizard_panel_disadventaged_center_deployment_lock_button", "interactable", show_lock)
  UI.setAttribute("wizard_panel_disadventaged_center_deployment_lock", "active", show_lock)

  g_game_settings['show_deployment_lines']['wizard'] = true
  update_deployment_lines()
  wizard_panel_disadventaged_center_deployment_update()
end

function on_wizard_panel_disadventaged_center_deployment_lock_prepared_defenses()
  UI.setAttribute("wizard_panel_disadventaged_center_deployment_lock_button", "interactable", false)
  on_next_frame( function()
    local disadvantage = get_tactical_disadvantage()
    local prepared_defenses = get_all_prepared_defenses()
    local players_prepared_defenses = filter_bases_by_player_color(prepared_defenses, disadvantage)
    for _, defense in pairs(players_prepared_defenses) do
      defense.setLock(true)
      add_prepared_defenses_decorations(defense)
    end
    wizard_panel_disadventaged_center_deployment_update()
  end)
end

function wizard_panel_disadventaged_center_deployment_update()
  on_next_frame( function()
    local interactable = UI.getAttribute("wizard_panel_disadventaged_center_deployment_lock_button", "interactable")
    local next_enabled = ("True" ~= interactable)
    UI.setAttribute("wizard_panel_disadvantaged_center_deployment_next", "interactable", next_enabled)
  end)
end

table.insert(wizard_panels, {name="wizard_panel_disadvantaged_center_deployment",
  exit=wizard_panel_exit_disadvantaged_center_deployment,
  enter=wizard_panel_disadventaged_center_deployment_enter})

  -------------------
  ------------------- wizard_panel_advantaged_deployment
  -------------------

  function on_wizard_panel_advantaged_deployment_previous()
    wizard_panel_show_panel_disadvantaged_center_deployment()
  end


  function on_wizard_panel_advantaged_deployment_next()
    wizard_panel_disadvantaged_deployment_show()
  end


  function wizard_panel_advantaged_deployment_exit()
    g_game_settings['show_deployment_lines']['wizard'] = nil
    update_deployment_lines()
  end


  function wizard_panel_advantaged_deployment_show()
    wizard_show_panel("wizard_panel_advantaged_deployment")
  end

  function wizard_panel_advantaged_deployment_enter()
    local advantage = g_game_settings['tactical_advantage']
    UI.setAttribute("wizard_panel_advantaged_deployment_who", "text", advantage)

    local flank = g_game_settings[ advantage .. "_flank_march"]
    UI.setAttribute("wizard_panel_advantaged_deployment_flank_march", "active", flank)

    local prepared_defenses = get_all_prepared_defenses()
    local players_prepared_defenses = filter_bases_by_player_color(prepared_defenses, advantage)
    local show_lock = not is_table_empty(players_prepared_defenses)
    UI.setAttribute("wizard_panel_advantaged_deployment_prepared_defenses_lock_button", "interactable", show_lock)
    UI.setAttribute("wizard_panel_advantaged_deployment_prepared_defenses_lock", "active", show_lock)

    g_game_settings['show_deployment_lines']['wizard'] = true
    update_deployment_lines()

    wizard_panel_advantaged_deployment_update()
  end

  function on_wizard_panel_advantaged_deployment_lock_prepared_defenses()
    UI.setAttribute("wizard_panel_advantaged_deployment_prepared_defenses_lock_button", "interactable", false)
    on_next_frame( function()
      local advantage = g_game_settings['tactical_advantage']
      local prepared_defenses = get_all_prepared_defenses()
      local players_prepared_defenses = filter_bases_by_player_color(prepared_defenses, advantage)
      for _, defense in pairs(players_prepared_defenses) do
        add_prepared_defenses_decorations(defense)
        defense.setLock(true)
      end
      wizard_panel_advantaged_deployment_update()
    end)
end

function wizard_panel_advantaged_deployment_update()
  on_next_frame( function()
    local interactable = UI.getAttribute("wizard_panel_advantaged_deployment_prepared_defenses_lock_button", "interactable")
    local next_enabled = ("True" ~= interactable)
    UI.setAttribute("wizard_panel_advantaged_deployment_next", "interactable", next_enabled)
  end)
end

table.insert(wizard_panels, {name="wizard_panel_advantaged_deployment",
    exit=wizard_panel_advantaged_deployment_exit,
    enter=wizard_panel_advantaged_deployment_enter})


    -------------------
    ------------------- wizard_panel_disadventaged_deployment
    -------------------

    function on_wizard_panel_disadvantaged_deployment_previous()
      wizard_panel_advantaged_deployment_show()
    end


    function on_wizard_panel_disadvantaged_deployment_next()
      wizard_show_panel_first_move()
    end


    function wizard_panel_disadvantaged_deployment_exit()
      g_game_settings['show_deployment_lines']['wizard'] = nil
      update_deployment_lines()
    end


    function wizard_panel_disadvantaged_deployment_show()
      wizard_show_panel("wizard_panel_disadvantaged_deployment")
    end

    function wizard_panel_disadventaged_deployment_enter()
      local disadvantage = get_tactical_disadvantage()
      UI.setAttribute("wizard_panel_disadvantaged_deployment_who", "text", disadvantage)
      g_game_settings['show_deployment_lines']['wizard'] = true
      update_deployment_lines()
    end

    table.insert(
      wizard_panels,
      {name="wizard_panel_disadvantaged_deployment",
       exit=wizard_panel_disadvantaged_deployment_exit,
       enter=wizard_panel_disadventaged_deployment_enter})

-------------------
------------------- First Move
-------------------

function on_wizard_panel_first_move_previous()
  wizard_panel_disadvantaged_deployment_show()
  g_game_settings['use_army_builder'] = true
  update_points_zones()
end


function on_wizard_panel_first_move_next()
  UI.setAttribute("panel_dba_orders_bg", "active", true)
  wizard_hide()
end


function wizard_show_panel_first_move()
  wizard_show_panel("wizard_panel_first_move")
end

function wizard_panel_first_move_enter()
  local advantage = g_game_settings['tactical_advantage']
  UI.setAttribute("wizard_panel_first_move_advantage", "text", advantage)
  g_game_settings['use_army_builder'] = false
  update_points_zones()
end

table.insert(wizard_panels, {name="wizard_panel_first_move", enter=wizard_panel_first_move_enter})

-------------------
-------------------
-------------------
