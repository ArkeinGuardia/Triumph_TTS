require("Triumph_TTS/scripts/log")
require("Triumph_TTS/scripts/contact")
require("Triumph_TTS/scripts/base_cache")
require("Triumph_TTS/scripts/logic_prepared_defenses")
require("Triumph_TTS/scripts/logic_decorations")
require("Triumph_TTS/scripts/utilities_lua")
require("Triumph_TTS/scripts/data/data_settings")


-- This caches the strokes for a given base in certain pos and rotation
g_cache_zocs = {}


function zoc_invalidate_cache()
    g_cache_zocs = {}
end


function _zoc_compare_transforms(a_transform, b_transform)
    if a_transform == b_transform then
        return true
    end
    if a_transform == nil then
        return false
    end
    if b_transform == nil then
        return false
    end
    local a_pos = a_transform.position
    local b_pos = b_transform.position
    if not equals_position(a_pos, b_pos, 0.02) then
        return false
    end
    local a_rot = a_transform.rotation
    local b_rot = b_transform.rotation
    if not equals_float(a_rot, b_rot, 0.00001) then
        return false
    end
    return true
end


-- Indicate that the location of a base for drawing 
-- ZOC has changed.
-- @param base_obj: Base whose location is being changed
-- @param transform: New location of the base for ZOC calculation.
--   Note that the transform might not be the actual bases location.
function zoc_set_transform(base_obj, transform)
    _zoc_initialize_base(base_obj)
    local base_guid = base_obj.getGUID()
    if _zoc_compare_transforms(g_cache_zocs[base_guid]['transform'], transform) then
        -- location  has not changed
        return
    end
    g_cache_zocs[base_guid]['transform'] = transform
    g_cache_zocs[base_guid]['zoc_max'] = nil
    g_cache_zocs[base_guid]['zocs'] = nil
    g_cache_zocs[base_guid]['strokes'] = nil
    for other_guid,_ in pairs(g_cache_zocs) do
        if other_guid ~= base_guid then
            if g_cache_zocs[other_guid].transform then
                if not _contact_far_enough(transform, g_cache_zocs[other_guid].transform) then
                    -- The other zoc might be blocked, re-examine.
                    g_cache_zocs[other_guid]['zoc_max'] = nil
                    g_cache_zocs[other_guid]['zocs'] = nil
                    g_cache_zocs[other_guid]['strokes'] = nil
                end
            end
        end
    end
    Global.setVectorLines({})
    -- Kludge if we schedule the redraw immediately the old lines just
    -- come back
    Wait.frames(function() draw_all_gizmos() end, 15)
end



function _zoc_get_color(base_obj)
    if is_base_blue_player(base_obj) then
        return g_gizmo_zoc_color_player_blue
    else
        return g_gizmo_zoc_color_player_red
    end
end


-- Return the rectangles that make up the ZOCs for a base.
function _zoc_calc_zocs(base_guid)
    if not g_cache_zocs then
        print_error("_zoc_calc_stroke_points: g_cache_zocs is nil")
        return {}
    end
    if not g_cache_zocs[base_guid] then
        print_error("_zoc_calc_stroke_points: g_cache_zocs[" .. base_guid .. "] is nil")
        return {}
    end
    if g_cache_zocs[base_guid].zocs then
        return g_cache_zocs[base_guid].zocs
    end
    if not g_cache_zocs[base_guid].transform then
        print_error("_zoc_calc_stroke_points:  g_cache_zocs[" .. base_guid .. "].transform is nil")
        return {}
    end
    if not g_cache_zocs[base_guid].base_size then
        print_error("_zoc_calc_stroke_points:  g_cache_zocs." .. base_guid .. ".base_size is nil")
        return {}
    end
    if not g_cache_zocs[base_guid].zoc_max then
        print_error("_zoc_calc_stroke_points:  g_cache_zocs[" .. base_guid .. "].zoc_max is nil")
        return {}
    end
    -- Rename common expressions to make it easier to work with.
    local size =  g_cache_zocs[base_guid].base_size
    local zoc_max =  g_cache_zocs[base_guid].zoc_max
    local rotation = g_cache_zocs[base_guid].transform.rotation
    local pos = g_cache_zocs[base_guid].transform.position

    local tr = { x = size['x'] / 2, y = 0, z = size['z'] / 2 }
    local tl = { x = -size['x'] / 2, y = 0, z = size['z'] / 2 }
    local br = { x = size['x'] / 2, y = 0, z = -size['z'] / 2 }
    local bl = { x = -size['x'] / 2, y = 0, z = -size['z'] / 2 }

    local zocs = {}

    -- TOP
    if zoc_max.top > 0 then
        local top = {}
        table.insert(top, {
            x = tr['x'],
            y = tr['y'],
            z = tr['z']
        })
        table.insert(top, {
            x = tr['x'],
            y = tr['y'],
            z = tr['z'] + zoc_max.top
        })
        table.insert(top, {
            x = tl['x'],
            y = tl['y'],
            z = tl['z'] + zoc_max.top
        })
        table.insert(top, {
            x = tl['x'],
            y = tl['y'],
            z = tl['z']
        })
        zocs['top'] = top
    end

    -- SIDE LEFT
    if zoc_max.left > 0 then
        local left = {}
        table.insert(left, {
            x = tl['x'] - zoc_max.left,
            y = tl['y'],
            z = tl['z']
        })
        table.insert(left, {
            x = bl['x'] - zoc_max.left,
            y = bl['y'],
            z = bl['z']
        })
        table.insert(left, {
            x = bl['x'],
            y = bl['y'],
            z = bl['z']
        })
        table.insert(left, {
            x = tl['x'],
            y = tl['y'],
            z = tl['z']
        })
        zocs['left'] = left
    end

    -- BOTTOM
    if zoc_max.bottom > 0 then
        local bottom = {}
        table.insert(bottom, {
            x = bl['x'],
            y = bl['y'],
            z = bl['z'] - zoc_max.bottom
        })
        table.insert(bottom, {
            x = br['x'],
            y = br['y'],
            z = br['z'] - zoc_max.bottom
        })
        table.insert(bottom, {
            x = br['x'],
            y = br['y'],
            z = br['z']
        })
        table.insert(bottom, {
            x = bl['x'],
            y = bl['y'],
            z = bl['z']
        })
        zocs['bottom'] = bottom
    end
    
    -- SIDE RIGHT
    if zoc_max.right > 0 then
        local right = {}
        table.insert(right, {
            x = br['x'] + zoc_max.right,
            y = br['y'],
            z = br['z']
        })
        table.insert(right, {
            x = tr['x'] + zoc_max.right,
            y = tr['y'],
            z = tr['z']
        })
        table.insert(right, {
            x = tr['x'],
            y = tr['y'],
            z = tr['z']
        })
        table.insert(right, {
            x = br['x'],
            y = br['y'],
            z = br['z']
        })
        zocs['right'] = right
    end

    for _, zoc in pairs(zocs) do
        for _, paux in pairs(zoc) do
            -- using side effect that paux is a reference to the entry in zocs
            local paux_rotated = rotate_point_relative(paux, pos, rotation)
            paux['x'] = paux_rotated['x']
            paux['y'] = set_vec_to_above_terrain(paux_rotated)['y']
            paux['z'] = paux_rotated['z']
        end
    end

    g_cache_zocs[base_guid].zocs = zocs
    return zocs
end


function _zoc_calc_stroke_points(base_guid)
    -- Result
    local zocs = _zoc_calc_zocs(base_guid)
    local stroke_points = {}
    for _, zoc in pairs(zocs) do
        for _,point in pairs(zoc) do 
            table.insert(stroke_points, point)
        end
    end
    return stroke_points
end


function _zoc_set_strokes(base_guid)
    -- ZOC is one base width in front.  See Rule 51.2
    if g_cache_zocs and g_cache_zocs[base_guid] and g_cache_zocs[base_guid].strokes then
        return g_cache_zocs[base_guid].strokes
    end

    local stroke_points =  _zoc_calc_stroke_points(base_guid)

    g_cache_zocs[base_guid].strokes =
        {
            points    = stroke_points,
            color     = g_cache_zocs[base_guid].color,
            thickness = g_line_thickness,
            rotation  = {0,0,0}
        }
end


function is_proxy_base(base_obj_cached)
    return str_has_substr(base_obj_cached.getName(), 'Proxy')
end


  
-- is there another base in front, flank, or rear contact.
-- See 18 FRONT, FLANK AND REAR CONTACT
function _set_close_combat_distance(base_guid)
    for other_guid,_ in pairs(g_cache_zocs) do
        if base_guid ~= other_guid then
            if g_cache_zocs[base_guid].color ~= g_cache_zocs[other_guid].color then
                if are_bases_in_close_combat(g_cache_zocs[base_guid].transform, g_cache_zocs[other_guid].transform) then
                    local all_edges_blocked = {top=0, left=0, bottom=0, right=0}
                    _zoc_add_blocker(base_guid, other_guid, all_edges_blocked)
                    _zoc_add_blocker(other_guid, base_guid, all_edges_blocked)
                    return true
                end
            end
        end
    end
    return false
end



function _zoc_segment_rectangle_intersections(segment, corners)
    local top = { corners.topleft, corners.topright}
    local bottom = { corners.botleft, corners.botright}
    local left = { corners.topleft, corners.botleft}
    local right = { corners.topright, corners.botright}
    local edges = {top, left, bottom, right}
    local intersections = {}
    for _,edge in pairs(edges) do
        local point = findLineSegmentIntersection(segment, edge)
        if point then
            table.insert(intersections, point)
        end
    end
    return intersections
end


-- Get the shape for the base that will block a ZOC.
function _zoc_blocker_shape(blocker_guid)
    -- shrink the blocker just a little bit so if it is snapped size by side
    --  to the base we are examining, the ZOC is not reducde
    local shrunken = shrink_rotated_rectangle(g_cache_zocs[blocker_guid].transform.corners, 0.02)
    local shape = { shrunken.topleft, shrunken.topright, shrunken.botright, shrunken.botleft }
    return shape
end


function _zoc_friendly_base_blocking_bases(blocked_guid, blocker_guid)
    if blocked_guid == blocker_guid then
        return
    end
    if g_cache_zocs[blocked_guid].color ~= g_cache_zocs[blocker_guid].color then
        return
    end
    local zocs = _zoc_calc_zocs(blocked_guid)
    local blocker_shape = _zoc_blocker_shape(blocker_guid)
    local constraints = shallow_copy(g_cache_zocs[blocked_guid].zoc_max)
    if zocs.top then
        if is_2d_shapes_intersecting(zocs.top, blocker_shape) then
            local zoc_edges = {
                { zocs.top[1], zocs.top[2] },
                { zocs.top[2], zocs.top[3] },
                { zocs.top[3], zocs.top[4] },
                { zocs.top[4], zocs.top[1] } }
            local intersecting_points = {}
            if is_point_in_2d_shape(g_cache_zocs[blocker_guid].transform.corners.topleft, zocs.top) then
                table.insert(intersecting_points, g_cache_zocs[blocker_guid].transform.corners.topleft)
            end
            if is_point_in_2d_shape(g_cache_zocs[blocker_guid].transform.corners.topright, zocs.top) then
                table.insert(intersecting_points, g_cache_zocs[blocker_guid].transform.corners.topright)
            end
            if is_point_in_2d_shape(g_cache_zocs[blocker_guid].transform.corners.botleft, zocs.top) then
                table.insert(intersecting_points, g_cache_zocs[blocker_guid].transform.corners.botleft)
            end
            if is_point_in_2d_shape(g_cache_zocs[blocker_guid].transform.corners.botright, zocs.top) then
                table.insert(intersecting_points, g_cache_zocs[blocker_guid].transform.corners.botright)
            end
            for _,zoc_edge in pairs(zoc_edges) do
                local segment_intersecting_points = _zoc_segment_rectangle_intersections(zoc_edge, g_cache_zocs[blocker_guid].transform.corners)
                for _,segment_intersecting_point in pairs(segment_intersecting_points) do
                    table.insert(intersecting_points, segment_intersecting_point)
                end            
            end
            if not is_table_empty(intersecting_points) then
                local blocked_top_edge = {
                    g_cache_zocs[blocked_guid].transform.corners.topleft,
                    g_cache_zocs[blocked_guid].transform.corners.topright}
                for _,intersecting_point in pairs(intersecting_points) do
                    local distance = distance_point_to_segment(intersecting_point, blocked_top_edge)
                    constraints.top = math.min(constraints.top, distance)
                end
                print("TODO SHRINKING TOP ", blocked_guid)
            end
        end
    end
    -- TODO check other edges for war wagons
    if not table_equals(constraints, g_cache_zocs[blocked_guid].zoc_max, true ) then
        _zoc_add_blocker(blocked_guid, blocker_guid, constraints)
    end
end


function _zoc_friendly_base_blocking(blocked)
    for blocker,_ in pairs(g_cache_zocs) do
        _zoc_friendly_base_blocking_bases(blocked, blocker)
    end
end


function _zoc_calc_zoc_max(guid)
    if not g_cache_zocs[guid] then
        g_cache_zocs[guid] = {}
    end
    if not g_cache_zocs[guid].zoc_max then
        _zoc_initialize_zoc_max(guid)
    end
    _set_close_combat_distance(guid)
    _zoc_friendly_base_blocking(guid)
end


function _can_have_zoc(base_obj)
    if is_proxy_base(base_obj) then
        return false
    end
    if is_base_prepared_defenses(base_obj) then 
        return false
    end
    if str_has_substr(base_obj.getName(), 'Elephant Screen') then
        return false
    end
    if str_has_substr(base_obj.getName(), 'Camp') then
      -- In Triumph! camps do not have a zoc
        return false
    end
    return true
end


function _zoc_initialize_base(base_obj)
    local guid = base_obj.getGUID()
    if not g_cache_zocs[guid] then
        g_cache_zocs[guid] = {}
    end
    if not g_cache_zocs[guid].base_size then
        g_cache_zocs[guid]['base_size'] = get_size(base_obj.getName())
        if not g_cache_zocs[guid].base_size then
            print_error("zoc_get_all_strokes unable to set size for " .. guid .. ' ' .. base_obj.getName())
            return {}
        end
    end
    if not g_cache_zocs[guid].color then
        g_cache_zocs[guid]['color'] = _zoc_get_color(base_obj)
    end
    if g_cache_zocs[guid].is_war_wagon == nil then
        g_cache_zocs[guid]['is_war_wagon'] = _is_war_wagon(base_obj)
    end
end


function zoc_get_all_strokes()
    if not g_zoc_enabled then
        return {}
    end

    local base

    local all_bases = get_all_bases()
    local cached_bases = {}
    for _, base in pairs(all_bases) do        
        if _can_have_zoc(base) then
            table.insert(cached_bases, build_base_cache(base))
        end
    end

    -- Verify the base has an entry, transform, size, color
    for _, base in pairs(cached_bases) do
        local guid = base.getGUID()
        _zoc_initialize_base(base)
        if not g_cache_zocs[guid].transform then
            g_cache_zocs[guid].transform = base.getTransform()
        end
    end

    -- After this point the bases are not used only the entries
    -- in g_cache_zocs

    -- Have all bases have valid zoc_max entries
    for guid,_ in pairs(g_cache_zocs) do
        if not g_cache_zocs[guid].zoc_max then
            _zoc_calc_zoc_max(guid)
        end
    end

    -- Have all bases have strokes
    for guid,_ in pairs(g_cache_zocs) do
        if not g_cache_zocs[guid].strokes then
            _zoc_set_strokes(guid)
        end
    end
    
    -- Return all the strokes
    local strokes = {}
    for guid,_ in pairs(g_cache_zocs) do
        table.insert(strokes, g_cache_zocs[guid].strokes)
    end
    return strokes
end

  

function _is_war_wagon(base_obj)
    if str_has_substr(base_obj.getName(), 'War Wagons') then
        return true
    end
    return false 
end


-- Clear the cache for a base
function zoc_invalidate_base(base_obj)
    guid = base_obj.getGUID()
    _zoc_invalidate_base_guid(guid)
end


function _zoc_invalidate_base_guid(base_guid)
    if g_cache_zocs[base_guid] then
        local blocks = g_cache_zocs[base_guid].blocks
        g_cache_zocs[base_guid] = nil
        if blocks then
            for blocked_guid, _ in pairs(blocks) do
                _zoc_invalidate_base_guid(blocked_guid)
            end
        end
    end
    Global.setVectorLines({})
    -- Kludge if we schedule the redraw immediately the old lines just
    -- come back
    Wait.frames(function() draw_all_gizmos() end, 15)
end


function _zoc_invalidate_strokes(guid)
    if g_cache_zocs[guid] then
        g_cache_zocs[guid].strokes = nil
    end
    Global.setVectorLines({})
    draw_all_gizmos()
end


function _zoc_is_transform_cached(base_guid, transform)
    if not g_cache_zocs[base_guid] then
        return false
    end
    if not g_cache_zocs[base_guid].transform then
        return false
    end
    if not table_equals(g_cache_zocs[base_guid].transform, transform, true) then
        return false
    end
    return true
end
    
-- Return the strokes that make up a zoc
-- base_guid: Identifier for to get the strokes for.
-- transform: Location of the base where we are getting the zoc for.
-- returns: table of strokes.  Table may be empty.
function zoc_get_strokes(base_guid, transform)
    if not _zoc_is_transform_cached(base_guid, transform) then
        _zoc_invalidate_base_guid(base_guid)
        g_cache_zocs[base_guid] = {}
        g_cache_zocs[base_guid].transform = transform
    end
    zoc_get_all_strokes()
    return g_cache_zocs[base_guid].strokes
end


function _zoc_initialize_zoc_max(guid)
    if g_cache_zocs[guid].is_war_wagon then
        g_cache_zocs[guid].zoc_max =
            {
                top=g_zoc_height_in_inches,
                left=g_zoc_height_in_inches,
                right=g_zoc_height_in_inches,
                bottom=g_zoc_height_in_inches                
            }
    else
        g_cache_zocs[guid].zoc_max =
            {
                top=g_zoc_height_in_inches,
                left=0,
                right=0,
                bottom=0                
            }
    end
end


-- indicated that blocker is reducing the zoc of blocked
-- zoc_max: Maximum size in inches that the blocked base can
-- have as their zoc.  dictionary of left, right, front, bottom.
function _zoc_add_blocker(blocked_guid, blocker_guid, zoc_max)
    if not g_cache_zocs[blocker_guid] then
        g_cache_zocs[blocker_guid] = {}
    end
    if not g_cache_zocs[blocker_guid].blocks then
        g_cache_zocs[blocker_guid].blocks = {}
    end
    g_cache_zocs[blocker_guid].blocks[blocked_guid] = true
    local after = shallow_copy(g_cache_zocs[blocked_guid].zoc_max)
    for k,v in pairs(zoc_max) do
        after[k] = math.min(v, g_cache_zocs[blocked_guid].zoc_max[k])
    end
    if not table_equals(g_cache_zocs[blocker_guid].zoc_max, after) then
        g_cache_zocs[blocked_guid].zoc_max = after
        g_cache_zocs[blocked_guid].zocs = nil
        g_cache_zocs[blocked_guid].strokes = nil
    end
end
